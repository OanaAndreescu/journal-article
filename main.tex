\documentclass[11pt]{article}

\usepackage{a4wide}
 
\usepackage[T1]{fontenc} 
\usepackage[scaled=.7]{beramono}
\usepackage{lmodern}  
\usepackage[utf8]{inputenc}
%\usepackage[english]{babel}      
\usepackage{amsmath}
\usepackage{amssymb}  
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{mathrsfs}   
\usepackage{ifdraft} 
\usepackage{array,multicol}  
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{cancel}
\usepackage{float}
\usepackage{stmaryrd} 
\usepackage{colortbl} 
\usepackage{caption}
\usepackage{mathpartir} 
\usepackage{mathtools}
\usepackage[final]{listings}
\usepackage{url}
%\usepackage{bibunits}% Incompatible with biblatex, see biblatex's documentation for workarounds.
\usepackage{marvosym} % Note that this exports \Cross, incompatible with package bbding.
%                     % Circumvented by code around the \usepackage{bdding} below.
\usepackage{forest}
\usepackage{tikz,datetime}
\usetikzlibrary{decorations.pathreplacing,trees,calc,fit,positioning,chains,arrows,arrows.meta,automata,shapes,graphs,shapes.geometric,shapes.symbols,
decorations.markings,patterns,matrix,decorations.pathmorphing,mindmap,math,
triangle-fit,decorations.growingwave,oni-squiggly}
\usepackage{pgf}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{alltt}
\usepackage{mathrsfs}
\usepackage{wrapfig}
\usepackage{xcolor}
\usepackage{dsfont}
\usepackage{amsbsy}
\usepackage{savesym}
% Circumvent incompatibility between marvosym and bdding, which both define \Cross.
% See https://groups.google.com/forum/#!topic/comp.text.tex/LSETDAIaJug
\savesymbol{Cross}% Save original \Cross as \origCross.
\usepackage{bbding}
\restoresymbol{bb}{Cross}% Restore original \Cross from marvosym + rename bbding's \Cross to \bbCross.
\usepackage{relsize} 
\usepackage{wasysym}
\usepackage{growingwave}  
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\usepackage{epigraph} 
\usepackage{oni-trees}
\usepackage{oni-tree-defaults}
%\usepackage[backend=bibtex,style=authoryear,natbib=true,maxbibnames=99]{biblatex}
%% User the bibtex backend with the authoryear citation style (which
%% resembles APA) 
\usepackage{tikz,datetime}
\usetikzlibrary{decorations.pathreplacing,trees,calc,fit,positioning,chains,arrows,arrows.meta,automata,shapes,graphs,shapes.geometric,shapes.symbols,
decorations.markings,patterns,matrix,decorations.pathmorphing,mindmap,math,triangle-fit,decorations.growingwave,oni-squiggly} 
\usepackage{pgf}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{subfigure}

%%%%%%%%%%
%% from main.tex




\newtheorem{definition}{Definition}

\newcommand{\snumber}[1]{\textrm{{\scriptsize(#1)}}}


%%%%% From Ch. 1
\def\slang{\textsf{Smart}}
\def\smil{\textsf{Smil}}
\def\prun{\textsf{Prove \& Run}}
\def\ptools{\textsf{ProvenTools}}
\def\pcore{\textsf{ProvenCore}}
\def\pcorem{\textsf{ProvenCore-M}}
\def\pvisor{\textsf{ProvenVisor}}


%%%%%
%%%%% From Chapter on SSMART
\newcommand{\disp}[1]{\lstinline&#1&}

%% True label
\def\lbtrue{\textsf{true}}
%% False Label
\def\lbfalse{\textsf{false}}


%Set of structure field identifiers
\def\fset{\ensuremath{\mathcal{F}}}
%Set of variant constructors identifiers
\def\cset{\ensuremath{\mathcal{C}}}
%Set of variable identifiers
\def\vset{\ensuremath{\mathcal{V}}}
%Set of writeable variable identifiers
\def\wrvset{\ensuremath{\mathcal{V}^{+}}}
%Set of read-only variable identifiers
\def\rovset{\ensuremath{\mathcal{V}^{-}}}
%Universe of type identifiers
\def\utyp{\ensuremath{\mathbb{T}}}
%Set of base type identifiers
\def\basetyp{\ensuremath{T_0}}
%Universe of semantic values
\def\uval{\ensuremath{\mathbb{D}}}
%Typing environment
\def\tenv{\ensuremath{\Gamma}}
%Valuation
\def\env{\ensuremath{E}}



%% Types
\def\primtyp{\tau}

%Structure Type
\newcommand{\plainstype}[6]
{\ensuremath{\boldsymbol{struct}\{#1_{#2}: #3, \ldots, #4_{#5}: #6 \}}}

\newcommand{\plainmiddlestype}[9]
{\ensuremath{\boldsymbol{struct}\{#1_{#2}: #3, \ldots, #4_{#5}: #6  , \ldots,#7_{#8}: #9\}}}

\def\commonstype{\plainstype{f}{1}{\tau}{f}{n}{\tau}}
\def\commonstypeindex{\plainstype{f}{1}{\tau_1}{f}{n}{\tau_n}}
\def\commonmiddlestype{\plainmiddlestype{f}{1}{\tau_1}{f}{i}{\tau_i}{f}{n}{\tau_n}}

%Variant Type
\newcommand{\plainvtype}[6]
{\ensuremath{\boldsymbol{variant}[#1_{#2}: #3 \ver \ldots \ver #4_{#5}: #6]}}

\newcommand{\plainmiddlevtype}[9]
{\ensuremath{\boldsymbol{variant}[#1_{#2}: #3 \ver \ldots \ver #4_{#5}: #6 \ver \ldots \ver #7_{#8}: #9]}}

\def\commonvtype{\plainvtype{C}{1}{\tau}{C}{n}{\tau}}
\def\commonvtypeindex{\plainvtype{C}{1}{\tau_1}{C}{n}{\tau_n}}
\def\commonmiddlevtype{\plainmiddlevtype{C}{1}{\tau_1}{C}{i}{\tau_i}{C}{n}{\tau_n}}

%Array Type
\newcommand{\plainatype}[2]
{\ensuremath{\boldsymbol{arr}^{#1} \langle #2 \rangle}}

\def\commonatype{\plainatype{\tau}{\tau}}
\def\commonatypeindex{\plainatype{\tau_i}{\tau}}

% Values

%Structure Values
\newcommand{\plainsval}[6]
{\ensuremath{\{#1_{#2} = #3, \ldots, #4_{#5} = #6\}}}

\newcommand{\plainmiddlesval}[9]
{\ensuremath{\{#1_{#2} = #3, \ldots, #4_{#5} = #6, \ldots, #7_{#8} = #9\}}}

\def\commonsval{\plainsval{f}{1}{v_1}{f}{n}{v_n}}
\def\commonmiddlesval{\plainmiddlesval{f}{1}{v_1}{f}{i}{v_i}{f}{n}{v_n}}

%% %Variant Values
%% \newcommand{\plainvval}[4]
%% {\ensuremath{#1_{#2}[#3_{#4}] }}

%% \newcommand{\plainvvalindex}[1]
%% {\ensuremath{C_{#1}[v_{#1}]}}

%% \def\commonvval{\plainvval{C}{i}{v}{i}}

%Array Values
\def\asup{\mathcal{P}}

%% Built-in Statements
\def\unop{\ensuremath{\boldsymbol{nop}}}
\newcommand{\plainasgn}[2]{\ensuremath{#1 := #2}}
\def\commonasgn{\plainasgn{o}{e}}
\newcommand{\plaineqtest}[2]{\ensuremath{#1 = #2}}
\def\commoneqtest{\plaineqtest{e_1}{e_2}}
\newcommand{\recordnew}{r := \{e_1, \ldots, e_n \}}
\newcommand{\recordall}{\{o_1, \ldots, o_n \} := r}
\newcommand{\recordset}{r' := \{r\; \boldsymbol{with}\; f_i = e \} }
\newcommand{\recordget}{o := r.f_i}
\newcommand{\recordeq}{r' = \langle  f_1, \ldots, f_k \rangle r''}
\newcommand{\varcons}{v := C_p[e]}
\newcommand{\varswitch}
{\boldsymbol{switch}(v) \;\boldsymbol{as} \;[o_1 \arrowvert \ldots \arrowvert o_n ]}
\newcommand{\varpossible}{v \in \{ C_1,\ldots ,C_k \}}
\newcommand{\arrayget}{o := a[i]}
\newcommand{\arrayset}{a' := [a \; \boldsymbol{with} \; i = e]}

\newcommand{\predcall}
{p(e_1, \ldots, e_n) \; [\lambda_1: \bar{o}_1 \; \arrowvert \ldots \arrowvert \; \lambda_m: \bar{o}_m]}
\newcommand{\pcall}
{
{p(e_1, \ldots, e_n)\newline
[\lambda_1: \bar{o}_1 \; \arrowvert \ldots \arrowvert \; \lambda_m: \bar{o}_m]}
}

%% Exit Labels

%% True label
\def\lbtrue{\textsf{true}}
%% False Label
\def\lbfalse{\textsf{false}}

%labels-outputs maps macros  
\newcommand{\unary}[1]{\left[\begin{array}{ccc}
              \lbtrue &\mapsto &#1\\
              \end{array}
       \right]}

\newcommand{\lbinary}[2]{
  \left[\begin{array}{c}
      \lbtrue \mapsto #1\\ 
      \lbfalse \mapsto #2
    \end{array}\right]
}

\newcommand{\multi}[4]{\left[\begin{array}{ccc}
              \lambda_{#1} &\mapsto & \bar{o}_{1}\\
               \vdots   &\ddots &\vdots \\
              \lambda_{#2} &\mapsto & \bar{o}_{#4}
              \end{array}
       \right]}

\newcommand{\multiv}[3]{\left[\begin{array}{ccc}
              \lambda_{#1} &\mapsto &o_{1}\\
               \vdots   &\ddots &\vdots \\
              \lambda_{#2} &\mapsto &o_{#3}
              \end{array}
       \right]}




%%%%%
%%%%% From Chapter on SMIL
\def\asmil{\textsf{$\alpha$Smil}}

\def\commonvval{\plainvval{C}{i}{v}}

%Generic option type
\def\optiont{\boldsymbol{\small{variant}}
[\textrm{\disp{Some}} : \boldsymbol{\small{struct}}\{\textrm{\disp{t}} : \textrm{\disp{T}}\} \; 
\arrowvert\; 
\; \textrm{\disp{None}} : \boldsymbol{\small{struct}}\{\}]}

%%%%% Chapter 5
\def\ileq{\dleq_{\intra}}
%\def\ijoin{\vee_{\intra}}
\def\ireduce{\oplus_{\intra}}
\def\uintra{\mathscr{D}}


%% misc macros
\newcommand{\ver}{\arrowvert \;}

%macros tables (chapters 5 and 7)
%!%!%! Does this impact tables in other chapters?
%!%!%!     If so, we can put it in a \begingroup \endgroup, so that it affects only the desired tables
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}} 
\colorlet{tableheadcolor}{gray!25} % Table header colour = 25% gray
\newcommand{\headcol}{\rowcolor{tableheadcolor}} %
\colorlet{tablerowcolor}{gray!10} % Table row separator colour = 10% gray
\newcommand{\rowcol}{\rowcolor{tablerowcolor}} %
\colorlet{tablerowcolor}{gray!10} % Table row separator colour = 10% gray %!%!%! was not in chapter 5.

% math operators with subscript-ish
%Macro big meet
\makeatletter
\newlength{\widthofMeet}
\newlength{\widthofR}

\newsavebox{\boxname}
\newsavebox{\boxnameb}
\newsavebox{\boxnamec}

\def\negphantomdiff#1#2#3{%
  \def\resetstyle{#1}
  \savebox{\boxname}{$#1#2$}%
  \savebox{\boxnameb}{$#1#3$}%
  \hspace{-\wd\boxnameb}\hspace{\wd\boxname}% negative width of just the R (= - whole + wedge)
}
\def\withwidthoffirst#1#2#3{%
  \def\resetstyle{#1}
  \savebox{\boxname}{$#1#2$}%
  \savebox{\boxnameb}{$#1#3$}%
  \hspace{\wd\boxnameb}\hspace{-\wd\boxname}%width of just the R (= whole - wedge)
  \usebox{\boxnameb}%
}
\def\alignedmathop#1#2{%
  \@ifstar{%
    \centeredmathop{#1}{#2}%
  }{%
    \mathchoice%
    {\negphantomdiff{\displaystyle}{#1}{#2}}% <--- HERE displaystyle
    {\negphantomdiff{\textstyle}{#1}{#2}}% <--- HERE textstyle
    {\negphantomdiff{\scriptstyle}{#1}{#2}}% <--- HERE scriptstyle
    {\negphantomdiff{\scriptscriptstyle}{#1}{#2}}% <--- HERE scriptscriptstyle
    \centeredmathop{#1}{#2}%
  }%
}
\def\centeredmathop#1#2{%
  \mathop{%
    \mathchoice%
    {\withwidthoffirst{\displaystyle}{#1}{#2}}% <--- HERE displaystyle
    {\withwidthoffirst{\textstyle}{#1}{#2}}% <--- HERE textstyle
    {\withwidthoffirst{\scriptstyle}{#1}{#2}}% <--- HERE scriptstyle
    {\withwidthoffirst{\scriptscriptstyle}{#1}{#2}}% <--- HERE scriptscriptstyle
  }%
}
\makeatother

% Needed to appear cleanly in the list of symbols
\def\intrachapfive{\Delta}
\def\ijoinchapfive{%
  \alignedmathop{%
    \vee%
  }{%
    \mathchoice%
    {\vee\mkern-4mu\smash{\raisebox{-0.3ex}{$\resetstyle\mathlarger{{}_{\intrachapfive}}$}}}%
    {\vee\mkern-3mu\smash{\raisebox{-0.1ex}{$\resetstyle\mathlarger{{}_{\intrachapfive}}$}}}%
    {\vee\mkern-2.25mu\smash{\raisebox{-0.3ex}{$\resetstyle\mathlarger{{}_{\intrachapfive}}$}}}%
    {\vee\mkern-2.5mu\smash{\raisebox{-0.35ex}{$\resetstyle\mathlarger{{}_{\intrachapfive}}$}}}%
  }%
}


\def\inpset{\mathcal{I}}

%%% From Chapter 9 ``Evaluation''
\tikzset{
>=stealth',
  punktchain/.style={
    rectangle, 
    rounded corners, 
    % fill=black!10,
   % draw=black, 
   % very thick,
    text width=10em, 
    minimum height=3em, 
    text centered, 
    on chain},
  line/.style={draw, thick, <-},
  element/.style={
    tape,
    top color=white,
    bottom color=blue!50!black!60!,
    minimum width=8em,
    draw=blue!40!black!90, very thick,
    text width=10em, 
    minimum height=3.5em, 
    text centered, 
    on chain},
  every join/.style={<-, thick,shorten >=1pt},
%  decoration={brace},
  tuborg/.style={decorate},
  tubnode/.style={midway, right=2pt},
}
\definecolor{caribbeangreen}{rgb}{0.0, 0.8, 0.6}



\title{Static analysis for proof obligation elimination in functional
  specifications}

\author{Oana Andreescu \and Thomas Jensen \and St\'ephane Lescuyer}

\date{\today}

\begin{document}

\begin{abstract}

\end{abstract}


\section{Introduction}

\subsection{The frame problem}

The frame problem~\cite{mccarthy69} was identified and described at
least as early as 1969 by McCarthy and Hayes, in the context of
Artificial Intelligence (AI). The initial description of the
frame problem is the following:

\begin{quotation}
``In proving that one person could get into conversation with another, we were
  obliged to add the hypothesis that if a person has a telephone he still has it
  after looking up a number in the telephone book. If we had a number of actions
  to be performed in sequence we would have quite a number of conditions to
  write down that certain actions do not change the values of certain
  fluents. In fact, with $n$ actions and $m$ fluents we might have to write down
  $mn$ such conditions.''
\end{quotation}

Unsurprisingly, 
%given its identification in the context of logicist AI, 
the frame problem manifests itself in the realm of formal software
specification and deductive verification as well~\cite{borgida93}.
Deductive verification methods consist in producing formal correctness
proofs, by first generating a set of formal mathematical proof
obligations from the program and its specification, and by
subsequently discharging these. Proof
obligations can sometimes be discharged automatically by using static
analysis and decision procedures, but  often they require the use of
an interactive prover. Reducing the number of proof obligations in a
verification hence becomes an essential task. 

A large part of a proof consists in proving that a global invariant is
preserved, despite the state changes that a program makes
as it executes.  A number of proof obligations deal with those parts of the
state that actually have been changed. Another set of proof
obligations arise from dealing with the part of the state that does
not change. These may be particularly tedious to handle because it 
should be ``evident'' that the invariant holds for this part of the
state. As a consequence, several specification formalisms offer the
possibility of specifying what is changed and what does not
change. These properties are called \emph{frame properties}.

Frame properties help reducing the number of proof
obligations. However, specifying frame properties might not seem dramatic
on small examples, but in real-world examples this quickly
escalates, leading to the necessity of specifying a plethora of
conditions.Writing such conditions is necessary but also notoriously
repetitive and tedious.  As Kogtenkov et al.~\cite{kogtenkov15}
so eloquently puts it:

\begin{quotation}
``It is hard enough to convince  programmers to state what their program does; forcing 
them in addition to specify all that it does not do may be a tough sell.'' 
\end{quotation}

The tedious, undeserved, manual effort entailed by the specification and
verification of frame properties is a manifestation of the frame problem. Though
certain conventions and approaches, such as the \emph{implicit frames} approach,
for specifying frame properties can alleviate the manual effort imposed, some
manifestation of the frame problem will be visible to some extent in the context
of any specification language and verification method.

The article proposes a solution to the frame problem based on
fully-automatic, static program analyses for inferring the
preservation of program invariants. More specifically, we target the
automatic identification of properties that depend only on an input
subset that is disjoint from an operation's \emph{frame}, i.e. the
state subset it modifies.

\subsection{Methodology}
\label{sec:methodology}

To this end, we propose a solution based on static analysis which does not
require any additional frame annotations. By detecting the subset
on which a property depends and by uncovering the part that is not modified by
an operation, as shown in Figure~\ref{ch1:fig:strategy}, we can automatically
discharge proof obligations related to unmodified parts. We employ two different
static analyses for this goal.

\begin{figure}[!h]
%Second Line
\begin{minipage}[c]{0.1\textwidth}
\[
\begin{array}[b]{crcl} 

\textrm{{Dependency}} & 
Obs
\left(
\mathord{%
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[ baseline= (current bounding box.center), scale=0.7, auto] 
    \filldraw[fill=lightgray!60,pattern = north west lines, pattern color=red, rounded corners]  (4.5,-8.5) rectangle (8.5,-5.5); 
    \filldraw[fill=lightgray!60] (4.5, -6.5) rectangle (8.5, -6.8); 
    \filldraw[fill=lightgray!60,pattern=vertical lines, pattern color=black] (4.5, -6.5) rectangle (8.5, -6.8); 
\end{tikzpicture}%
}
}
\right)
 & = &
Obs
\left(
\mathord{%
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[baseline=(current bounding box.center), scale=0.7, auto]
  \filldraw[fill=red!75!black, rounded corners] (12,-12) rectangle (16,-9) ;% draw/fill the box
  \filldraw[pattern = north east lines, pattern color=white, rounded corners]  (12,-12) rectangle (16,-9) ;% draw the stripes
  \filldraw[fill=lightgray!40] (12, -10) rectangle (16, -10.3);
  \filldraw[pattern=vertical lines, pattern color=black] (12, -10) rectangle (16, -10.3);
\end{tikzpicture}%
}
}
\right) \\[1.5em]
 
\textrm{{Correlation}} &
\textrm{\huge{$f$}}
\left (
\mathord{%
\resizebox{\textwidth}{!}{ 
\begin{tikzpicture}[baseline=(current bounding box.center), scale=0.7, auto]
    \filldraw[fill=lightgray!60, rounded corners]  (1,-10) rectangle (5,-7) 
    node[scale=1.5,rectangle, minimum size = 2] at (3,-7.5) {\Large$?$} 
    node[scale=1.5,rectangle, minimum size = 2] at (3, -9) {\Large$?$}; 
    \filldraw[fill=lightgray!60] (1, -8) rectangle (5, -8.3); 
    \filldraw[fill=lightgray!60,pattern=vertical lines, pattern color=black] (1, -8) rectangle (5, -8.3); 
\end{tikzpicture}%
}
}
\right)
&  =  &
\mathord{%
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[baseline=(current bounding box.center), scale=0.7, auto]
        \filldraw[fill=darkgray!60, rounded corners]  (12,-10) rectangle (16,-7) 
            node[scale=1.5,rectangle, minimum size = 2] at (14,-7.5) {\Large$?$}
            node[scale=1.5,rectangle, minimum size = 2] at (14, -9) {\Large$?$};;% draw the box
       \filldraw[fill=lightgray!40] (12, -8) rectangle (16, -8.3);
    \filldraw[fill=lightgray!40,pattern=vertical lines, pattern color=black] (12, -8) rectangle (16, -8.3);
\end{tikzpicture}%
}
} \\[1.5em]

\textrm{{Invariant}} &
Obs
\left (
\mathord{%
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[baseline=(current bounding box.center), scale=0.7, auto]
    \filldraw[fill=lightgray!40,pattern = north west lines, pattern color=red, rounded corners]  (1,-12) rectangle (5,-9); 
    \filldraw[fill=lightgray!40] (1, -10) rectangle (5, -10.3); 
    \filldraw[fill=lightgray!40,pattern=vertical lines, pattern color=black] (1, -10) rectangle (5, -10.3); 
\end{tikzpicture}%
}
}
\right)
 & \Rightarrow & Obs
\left (
\textrm{\huge{$f$}}
\left(
\mathord{%
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[baseline=(current bounding box.center), scale=0.7, auto]
        \filldraw[fill=lightgray!40,pattern = north west lines, pattern color=red, rounded corners]  (12,-12) rectangle (16,-9) ;% draw the box
       \filldraw[fill=lightgray!40] (12, -10) rectangle (16, -10.3);
    \filldraw[fill=lightgray!40,pattern=vertical lines, pattern color=black] (12, -10) rectangle (16, -10.3);
\end{tikzpicture}%
}
}
\right)
\right) 
\end{array}
\]
\end{minipage}
\caption{Frame Problem and Solution Strategy}
\label{ch1:fig:strategy}
\end{figure}

The first analysis of our two-step strategy is a \emph{dependency
  analysis}, which detects the input subset $\delta$ on which the
outcome of an operation or of a logical property $\mathscr{L}$
relies. This subset is represented by the grey rectangle with vertical
lines in Figure~\ref{ch1:fig:frameproblem}. The second is a
\emph{correlation analysis}, meant to detect the subset $\xi$ modified
by an operation $\mathscr{O}$, illustrated by the orange
rectangles with inclined lines in
Figure~\ref{fig:frameproblem}. By employing these two static
analyses, thus detecting $\delta$ and $\xi$ automatically, and by
subsequently reasoning based on their combined results, we can infer
the preservation of the property $\mathscr{L}$ for the post-state of
$\mathscr{O}$.

\subsection{Application context: Formal verification of systems software}

\subsection{Organisation of the article}

\section{The SMART functional specification language}

\section{Dependency analysis}

\input{dependency-macros}

The dependency analysis delimits the input subset on which the output
depends, in the context of an operation with a compound input. We
define \emph{dependency} as the observed part of a structured domain
and strive to obtain type-sensitive results, distinguishing between
the subelements of arrays and algebraic data types and capturing the
dependency specific to each. The targeted results are meant to mirror
-- in terms of dependency -- the layered structure of compound data
types.  Furthermore, the \emph{dependency analysis} must work with
\emph{conservative approximations} and it must guarantee that what is
marked as not needed is definitely not needed, i.e. it is irrelevant
for the obtained output.

In the classification of Hind~\cite{hind01}, our dependency analysis is a 
\emph{flow-sensitive}, \emph{field-sensitive}, \emph{interprocedural} analysis
that handles associative arrays, structures and variant data types. Specific
dependency results are computed for each of the possible execution
scenarios, i.e. for each exit label. Thus, our analysis also shows a form of
\emph{path-sensitivity}~\cite{hind01}. However, we favour the term 
\emph{label-sensitivity} to describe this characteristic, as it seems more 
appropriate applied to our case and the language we are working with.

Our dependency analysis targets complex transition systems in general, and 
operating systems and microkernels in particular.
%% Generally, our dependency analysis targets complex transition systems, such as 
%% microkernels and operating systems, for example.
These are
characterized by states defined by complex compound data structures and by 
transitions, i.e. state changes, that map an input state to an output state. 
Automatically proving the preservation of invariants concerning only 
subelements of the state, i.e. fields, array cells, etc., that have not been 
altered by a transition in the system would considerably diminish the number of 
proof obligations. The first step towards achieving this goal consists in 
automatically detecting dependency summaries and the minimum relevant input
information for producing certain outputs.

As mentioned, our analysis targets fine-grained dependency summaries for arrays,
structures and variants, expressed at the level of their subelements. For 
variants, besides capturing the specific dependency on each constructor 
and its arguments, we argue that additional, relevant information can be 
computed, regarding the subset of possible constructors at a given program 
point. This is not dependency information \emph{per se} but it enriches the 
footprint of a predicate with useful information. Together with the dependency 
information, this additional information about constructors is meant to answer 
the same question, namely, what fragments of the input influence the output, 
from a different, albeit related point of view. Therefore, we are 
simultaneously performing a \emph{possible-constructors} analysis. This has an 
impact on the defined abstract dependency type, making it more complex, as we will see in 
the following section. The \emph{possible-constructors} analysis could be 
performed separately, as a stand-alone analysis. By performing the two analyses 
simultaneously, we lose some of the precision that would be attained if the two 
were performed separately, but we reduce overhead and present relevant 
information in a unified manner.  

Designing the analysis as a tool to be used in the context of
interactive program verification, on both code and specifications, has
led to specific traits. One of them concerns the treatment of
arrays. In contrast to dependence and liveness analyses used for code
optimizations~\cite{gross90}, which require precision for every
array cell, we compute dependency information referring to all cells
of the array or to all but one cell, for which an exceptional
dependency is computed.  In practice, a considerable number of
relevant properties and operations involving arrays fall into this
spectrum.

 

%% Frequently operations manipulating arrays are concerned only with 
%% one element; others, such as sorting algorithms are concerned and potentially 
%% modify every element. Properties on arrays most often refer to all cells of an 
%% array or to one cell, imposing conditions of the \emph{forall} or \emph{exists}
%% type. Properties on arrays often address somehow a \emph{uniform} quality 
%% applying to all elements of the array or to ...         

\subsection{Targeted Dependency Information}\label{sec:intro:example}

We briefly present two examples of {\asmil} predicates \disp{thread}
and \disp{start_address}, 
manipulating structures, variants and arrays and describe the dependency 
information that we are targeting.
Both predicates manipulate inputs of type
\disp{process},  and handle values of type \disp{thread} and
\disp{memory_region}. 

\begin{figure}[hbtp]\centering
\begin{tabular}{ll}
\toprule
\begin{lstlisting}
type memory_region = {
 // Start address 
 start : int;  
 // Region length 
 length : int
}
\end{lstlisting}
&\begin{lstlisting}
type thread = {
 // Identifier
 id : int;
 // Current state 
 crt_state : state;
 // Stack 
 stack : memory_region 
}
\end{lstlisting} \\
\bottomrule
\end{tabular}
\caption{Example Data Types -- Thread and Memory Region}
\label{ex:atype}
\end{figure}

\begin{figure}[hbtp]\centering
\begin{tabular}{ll}
\toprule
\begin{lstlisting}
type option<A> = 
  | None
  | Some (A a)
\end{lstlisting}
&\begin{lstlisting}
type process = {
 // Array of associated threads 
 threads : array<option<thread>>;
 // Internal id
 pid : int; 
 // Currently running thread 
 crt_thread : int;
 // Address space 
 adr_space : address_space
}
\end{lstlisting}
\\
\bottomrule
\end{tabular}
\caption{Input Type -- Process}
\label{ex:itype}
\end{figure}
  
The first predicate, \disp{thread}, having the control flow graph shown in 
Figure~\ref{pred:cfg:thread} and whose implementation is shown in 
Figure~\ref{ex:thread:code}, receives a process \disp{p} and an index \disp{i} 
as inputs. It reads the \disp{i}-th element in the \disp{threads} array of the 
input process \disp{p}. If this element is active, then the predicate exits with   
the label \disp{true} and outputs the corresponding thread \disp{ti}. Otherwise, 
it exits with the label \disp{None} and no output is generated.

\begin{figure}[!h]
\begin{lstlisting}
predicate thread(process p, int i)
 -> [true: thread ti|None|oob]
{{array<option<thread>> th, option<thread> tio}} {
  th := p.threads : [true -> 1];
  tio := th[i] : [true -> 2, false -> 5];
  switch (tio) as [ |ti] : [None -> 4, Some -> 3];
  [true];
  [None];
  [oob]
}
\end{lstlisting}
\caption{Predicate \disp{thread} -- Implementation}
\label{ex:thread:code}
\end{figure}

\begin{figure}[!h]\centering
\resizebox{0.7\textwidth}{!}{%
\begin{tabular}{@{}c@{}}
\toprule
{ \centering
  \hspace{1.6cm}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {{th := p.threads}};
   \node[statt]         (N2) [below=1cm of N1] { {tio := th[i]}};
   \node[statt]         (N3) [below left=of N2] { {$\boldsymbol{switch}$(tio) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   \node[statt]         (N5) [below left=of N3]{\lbtrue};
   \node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge              node[xshift=-0.95cm] {{\lbtrue}} (N2);
   \path (N2) edge              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   \path (N2) edge              node {{\lbfalse}} (N4);
   \path (N3) edge              node[left, anchor=south east] { {\textsf{Some}}} (N5);
   \path (N3) edge              node[right, anchor=south west] { {\textsf{None}}} (N6);
\end{tikzpicture}
 }
\\
\bottomrule
\end{tabular}
}
\caption{$G_{\mathit{thread}}$ -- Control Flow Graph of Predicate \disp{thread}}
\label{pred:cfg:thread}
\end{figure}


\begin{figure}[hbtp]
\resizebox{0.95\textwidth}{!}{
\begin{tabular}{lll}
\toprule
\begin{tikzpicture}
\tikzset{
    position label/.style={
       below = 3pt,
       text height = 1.5ex,
       text depth = 1ex
    },
   brace/.style={
     decoration={brace},
     decorate
   }
}

\node at (3,9) {\Huge Exit label \lbtrue:};

\draw[dotted] (0,0) grid[xstep=8, ystep = 2] (8,8);
\fill[lightgray, opacity=0.2] (0,0) rectangle (8,8);
\node at (4,1) {\Huge adr\_space};
\node at (4,3) {\Huge crt\_thread};
\node at (4,5) {\Huge pid};
\node at (4,-1) {\Huge process p};
\draw[help lines] (0,6) grid[xstep=0.5, ystep = 2] (8,8);
\node at (1,7.5)  (nr) {} ;

\fill[caribbeangreen](2.5,6) rectangle (3,8);
\draw[pattern=north west lines, pattern color=black] (2.5,6) rectangle (3,8);
\node at (4,7) {\Huge threads};
\end{tikzpicture}
%
&\begin{tikzpicture}
\tikzset{
    position label/.style={
       below = 3pt,
       text height = 1.5ex,
       text depth = 1ex
    },
   brace/.style={
     decoration={brace},
     decorate
   }
}
%
\node at (3,9) {\Huge Exit label \textsf{None}:};

\draw[dotted] (0,0) grid[xstep=8, ystep = 2] (8,8);
\fill[lightgray, opacity=0.2] (0,0) rectangle (8,8);
\node at (4,1) {\Huge adr\_space};
\node at (4,3) {\Huge crt\_thread};
\node at (4,5) {\Huge pid};
\node at (4,-1) {\Huge process p};
\draw[help lines] (0,6) grid[xstep=0.5, ystep = 2] (8,8);
\node at (1,7.5)  (nr) {} ;

\fill[red, opacity=0.3](2.5,6) rectangle (3,8);
\draw[pattern=north west lines, pattern color=black] (2.5,6) rectangle (3,8);
\node at (4,7) {\Huge threads};
\end{tikzpicture}
%
&\begin{tikzpicture}[node distance=0.5cm, legend-square/.style={draw=black!50!white, draw opacity=1, minimum width=1cm, minimum height=1cm, inner sep=0pt, anchor=north west}]
\node[anchor=base west] at (29,1.8) {\Large option<thread>:};
\node[fill=caribbeangreen,legend-square] (legend-green) at (29,1) {};
\node[right=of legend-green] {\Large Some(thread t)};
\node[fill=red,opacity=0.3,legend-square] (legend-red) at (29,-1) {};
\node[right=of legend-red]  {\Large None};

\node[pattern=north west lines, pattern color=black, preaction={fill=lightgray, opacity=0.2},legend-square] (legend-gray-lines) at (29,6) {};
\node[anchor=base west, right=of legend-gray-lines] {\Large Read/Needed};

\node[fill=lightgray, opacity=0.2, minimum width=1cm, minimum height=1cm,legend-square] (legend-gray) at (29,4) {};
\node[anchor=base west,right=of legend-gray] {\Large Irrelevant/Not Needed};

\path[draw=none,fill=none](29,-3.5) rectangle (31,0);
\end{tikzpicture}\\
\bottomrule
%
\end{tabular}
}
\caption{Targeted Dependency Results for Predicate \disp{thread}}
\label{ex:res:thread}
\end{figure}

Our dependency analysis should be able to distinguish between the different
exit labels of the predicate. For the label \disp{true} for instance, it
should detect that only the field \disp{threads} is read by the predicate,
while all others are irrelevant to the result. Furthermore, it should detect 
that for the \disp{threads} array of the input \disp{p} only the \disp{i}-th
element is inspected. Additionally, since we are considering the label 
\disp{true}, the \disp{i}-th element is necessarily an \emph{active} thread, 
indicated by the constructor \disp{Some}. The other constructor, \disp{None}, is 
\emph{impossible} for this execution scenario. On the contrary, for the exit 
label \disp{None}, the constructor \disp{Some} is impossible. For the exit label
\disp{oob}, nothing but the index \disp{i} and the ``support'' or ``length'' of the
associated \disp{threads} array is read. The targeted dependency results for the 
predicate \disp{thread} are depicted in Figure~\ref{ex:res:thread}.     
%% The second predicate, \disp{start_address}, whose control flow graph is shown in
%% Figure~\ref{ch4:pred:cfg:start}, receives a process \disp{p} and an index \disp{j} 
%% as inputs and finds the start address of the stack corresponding to an active thread. 

\begin{figure}[hbtp]\centering
\resizebox{0.7\textwidth}{!}{%
\begin{tabular}{@{}c@{}}
\toprule
{ \centering
  \hspace{1.6cm}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {\large {thread(p, j)[true: tj | None | oob]}};
   \node[statt]         (N2) [below left=of N1] {\large {sj := tj.stack}};
   \node[statt]         (N3) [below right=of N1] {\textsf{None}};
   \node[statt]         (N4) [below=1cm of N2]{\large {adr := sj.start}};
   \node[statt]         (N5) [below=1cm of N4]{\lbtrue}; 
   \node[statt]         (N6) [below=of N1]{\textsf{error}}; 
   \path (N1) edge              node[xshift=-0.05cm, yshift=0.15cm] {\large {\lbtrue}} (N2);
   \path (N1) edge              node {\large {\textsf{None}}} (N3); 
   \path (N2) edge              node {\large {\lbtrue}} (N4);
   \path (N4) edge              node{\large {\lbtrue}} (N5);
   \path (N1) edge              node {\large {\textsf{oob}}} (N6); 
\end{tikzpicture}
 }
\\
\bottomrule
\end{tabular}
}
\caption{$G_{\mathit{start\_address}}$ -- Control Flow Graph of Predicate \disp{start_address}}
\label{ch4:pred:cfg:start}
\end{figure}

The second predicate, \disp{start_address}, whose control flow graph is shown in
Figure~\ref{ch4:pred:cfg:start}, receives a process \disp{p} and an index \disp{j} 
as inputs and finds the start address of the stack corresponding to an active thread.
It makes a call to the predicate \disp{thread}, thus reading the 
\disp{j}-th element of the \disp{threads} array of its input process. If this is 
an active element, it further accesses the field \disp{stack}, from which it 
only reads the start address \disp{start}. Otherwise, if the element is inactive, 
the predicate forwards the exit label \disp{None} of the called predicate \disp{thread} 
and generates no output. When given an invalid index \disp{i}, the predicate exits
with label \disp{oob}. 
The predicate's implementation is shown in Figure~\ref{ex:start:code}.  

\begin{figure}[hbtp]
\begin{lstlisting}
predicate start_address(process p, int j)
 -> [true: int adr|None]
{{thread tj, memory_region sj}} {
  thread(p, j)[true: tj | None | oob] : [true -> 1, 
   None -> 4, oob -> 5];
  sj := tj.stack : [true -> 2];
  adr := sj.start : [true -> 3];
  [true];
  [None];
  [error] 
}
\end{lstlisting}
\caption{Predicate \disp{start_address} -- Implementation}
\label{ex:start:code}
\end{figure}

The dependency information for this predicate should capture the fact that on the
\disp{true} execution scenario, only the field \disp{start} of the input's 
\disp{j}-th associated thread is read. Furthermore, the only possible constructor
on this execution path is the \disp{Some} constructor. On the contrary, for the
\disp{None} execution scenario the only possible constructor is the \disp{None}
constructor. The targeted dependency results for the \disp{start_address} 
predicate are depicted in Figure~\ref{ex:res:start}. We remark that for the \disp{oob}
execution scenario, only the ``support'' or ``length'' of the \disp{threads} array is
read. 
  
\begin{figure}[hbtp]
\resizebox{0.95\textwidth}{!}{
\begin{tabular}{lll}
\toprule
\begin{tikzpicture}
\tikzset{
    position label/.style={
       below = 3pt,
       text height = 1.5ex,
       text depth = 1ex
    },
   brace/.style={
     decoration={brace},
     decorate
   }
}

\node at (3,9) {\Huge Exit label \lbtrue:};

\draw[dotted] (0,0) grid[xstep=8, ystep = 2] (8,8);
\fill[lightgray, opacity=0.2] (0,0) rectangle (8,8);
\node at (4,1) {\Huge adr\_space};
\node at (4,3) {\Huge crt\_thread};
\node at (4,5) {\Huge pid};
\node at (4,-1) {\Huge process p};
\draw[help lines] (0,6) grid[xstep=0.5, ystep = 2] (8,8);
\node at (1,7.5)  (nr) {} ;

\fill[caribbeangreen](2.5,6) rectangle (3,8);
\node (tj) at (2.8,7.8) {};
\node at (4,7) {\Huge threads};

\draw[dotted] (9,11) rectangle (12,12);
\fill[lightgray, opacity=0.2] (9,11) rectangle (12,12);
\node at (10.5,11.5) {\huge id};

\draw[dotted] (9,10) rectangle (12,11);
\fill[lightgray, opacity=0.2] (9,10) rectangle (12,11);
\node at (10.5,10.5) {\Large crt\_state};

\draw[dotted] (9,9) rectangle (12,10);
\fill[lightgray, opacity=0.2] (9,9) rectangle (12,10);
\node (s) at (10.5,9.5) {\Large stack};
\node (s2) at (9, 9.5) {};
\node at (10.5,8.5) {\huge thread tj};


\draw[dotted] (14,9) rectangle (16,10);
\fill[lightgray, opacity=0.2] (14,9) rectangle (16,10);
\draw[pattern=north west lines, pattern color=black, opacity=0.5] (14,9) rectangle (16,10);
\node (a) at (15,9.5) {\Huge start};
\node at (16,8.5) {\huge stack stj};

\draw[dotted] (16,9) rectangle (18,10);
\fill[lightgray, opacity=0.2] (16,9) rectangle (18,10);
\node at (17,9.5) {\huge length};

\draw[->, very thick] (s) edge (a); 
\draw[->, very thick, out=90] (tj) edge (s2);

\end{tikzpicture}
%
&\begin{tikzpicture}
\tikzset{
    position label/.style={
       below = 3pt,
       text height = 1.5ex,
       text depth = 1ex
    },
   brace/.style={
     decoration={brace},
     decorate
   }
}
%
\node at (3,9) {\Huge Exit label \textsf{None}:};

\draw[dotted] (0,0) grid[xstep=8, ystep = 2] (8,8);
\fill[lightgray, opacity=0.2] (0,0) rectangle (8,8);
\node at (4,1) {\Huge adr\_space};
\node at (4,3) {\Huge crt\_thread};
\node at (4,5) {\Huge pid};
\node at (4,7) {\Huge threads};
\node at (4,-1) {\Huge process p};
\draw[help lines] (0,6) grid[xstep=0.5, ystep = 2] (8,8);
\node at (1,7.5)  (nr) {} ;

\fill[red, opacity=0.3](2.5,6) rectangle (3,8);
\draw[pattern=north west lines, pattern color=black] (2.5,6) rectangle (3,8);
%\draw[dotted, red] (2.5,6) rectangle (3,8);
\end{tikzpicture}
%
&\begin{tikzpicture}[node distance=0.5cm, legend-square/.style={draw=black!50!white, draw opacity=1, minimum width=1cm, minimum height=1cm, inner sep=0pt, anchor=north west}]
\node[anchor=base west] at (29,1.8) {\Large option<thread>:};
\node[fill=caribbeangreen,legend-square] (legend-green) at (29,1) {};
\node[right=of legend-green] {\Large Some(thread t)};
\node[fill=red,opacity=0.3,legend-square] (legend-red) at (29,-1) {};
\node[right=of legend-red]  {\Large None};

\node[pattern=north west lines, pattern color=black, preaction={fill=lightgray, opacity=0.2},legend-square] (legend-gray-lines) at (29,6) {};
\node[anchor=base west, right=of legend-gray-lines] {\Large Read/Needed};

\node[fill=lightgray, opacity=0.2, minimum width=1cm, minimum height=1cm,legend-square] (legend-gray) at (29,4) {};
\node[anchor=base west,right=of legend-gray] {\Large Irrelevant/Not Needed};

\path[draw=none,fill=none](29,-3.5) rectangle (31,0);
\end{tikzpicture}\\
\bottomrule
%
\end{tabular}
}
\caption{Targeted Dependency Results for Predicate \disp{start_address}}
\label{ex:res:start}
\end{figure}

\subsection{The dependency abstract domain}
\label{sec:depdom}

The first step towards inferring expressive, type-sensitive results that capture
the dependency specific to each subelement of an algebraic data type or an 
associative array, is the definition of an \emph{abstract dependency domain} 
%\defsymbol{$\udep$}{Abstract dependency domain}%
$\udep$, that mimics the structure of such data types. The dependency domain $\delta \in 
\udep$, shown below, is defined inductively from the three atomic cases --- 
$\everything$, $\nothing$ and $\impossible$ --- and mirrors the structure of the 
concrete types. 
%
\begin{definition}\label{ch5depdom}{Dependency Domain $\delta \in 
\udep$.}
\[
\begin{array}{lllr}
\dom := &\ver \everything &\textrm{\emph{Everything} -- atomic case} &\snumber{i}\\
        &\ver \nothing    &\textrm{\emph{Nothing} -- atomic case} &\snumber{ii}\\
        &\ver \impossible &\textrm{\emph{Impossible} -- atomic case} &\snumber{iii}\\
        &\ver \structdom{\dstruct{1}}{\dstruct{n}} &f_1, \ldots, f_n \textrm{ fields} &\snumber{iv}\\
        &\ver \vardom{\dvar{1}}{\dvar{m}} & C_1, \ldots, C_m  \textrm{ constructors}  &\snumber{v}\\
        &\ver \adom{\dom} & &\snumber{vi}                      \\
        &\ver \addef & i \; \textrm{array index} & \snumber{vii}\\
\end{array}
\]
\end{definition}
%
\noindent As reflected by the above definition, the dependency for atomic types
is expressed in terms of the domain's atomic cases: \everything{} (least
precise), denoting that \emph{everything} is needed and \nothing, denoting that
\emph{nothing} is needed. The third atomic case \impossible, denoting
\emph{impossible}, is introduced for the \emph{possible constructors} analysis
performed simultaneously, and is further explained below.

The dependency of a structure {\snumber{iv}} describes the dependency on each of 
its fields. %% For example, the dependency assigned to a structure having three 
%% fields, $f$, $g$ and $h$, in the context of a predicate operating on it and 
%% reading only the $h$ field, while ignoring the other two fields, could be of the 
%% following form: $\{f \mapsto \oslash, g \mapsto \oslash, h \mapsto \top \}$. 
For instance, revisiting our \disp{thread} example from 
Section~\ref{sec:intro:example}, we could express an over-approximation of the 
dependency information depicted for the process \disp{p} in 
Figure~\ref{ex:res:thread} using the following dependency: 
%
\[
\{\mathit{threads} \mapsto \top; \; \mathit{pid} \mapsto \oslash; \; 
\mathit{crt\_thread} \mapsto \oslash; \; \mathit{adr\_space} \mapsto \oslash \}.\]
%
This captures the fact that all fields except the \disp{threads} field are 
irrelevant, i.e. they are not read and \emph{nothing} in their contents is 
needed. The dependency for the \disp{threads} field is an over-approximation
and expresses the fact that it is entirely necessary, i.e. \emph{everything} in 
its value is needed for the result.   

For arrays we distinguish between two cases, namely arrays with a general 
dependency applying to all of the cells {given by \snumber{vi}} and arrays with a 
general dependency applying to \emph{all but one} exceptional cell, for which a specific 
dependency is known {given by \snumber{vii}}. %% For example, the dependency assigned to an
%% array having elements of the structured type with three fields used above, 
%% considered in the context of a predicate reading only the field $h$ of the $i$-th
%% array element and ignoring everything else, could be of the following form:
%% $\aexcdom{\oslash}{i}{\{f \mapsto \oslash, g \mapsto \oslash, h \mapsto \top \}}$.
For instance, for the \disp{threads} field of the previous example, the 
following dependency:
%
\[
\aexcdom{\oslash}{i}{\top}
\]
%
would be a less coarse approximation, capturing the fact that only the \disp{i}-th 
element of the associated \disp{threads} array is needed, while all others are 
irrelevant.

For variants {\snumber{v}}, the dependency is expressed in terms of the 
dependencies of their constructors, expressed in turn in terms of their 
arguments' dependencies. Thus, a constructor having a dependency mapped to 
\nothing{} is one for which nothing but the \emph{tag} has been read, i.e. its 
arguments, if any, are irrelevant for the execution. %% For instance, the dependency assigned to a 
%% variant having two constructors $A$ and $B$, in the context of a predicate that
%% only reads the tag for the $A$ constructor and depends completely on the $B$
%% constructor, could be of the following form:
%% $[A \mapsto \oslash; B \mapsto \top]$. 
For instance, for the \disp{i}-th element of the \disp{threads} array of our 
previous example, the following dependency:
%
\[
[\mathit{Some} \mapsto \top; \mathit{None} \mapsto \oslash]
\]
%
would be a more precise approximation, when considering the exit label 
\disp{true}. It is still an over-approximation as it expresses that both
constructors are possible. The argument of the \disp{Some} constructor is
entirely read, while for \disp{None} only the tag is read. 
%% This expresses the fact that the only possible constructor is 
%% \disp{Some} and that its argument is entirely read.

For variants, we want to take a step further and to also include the information 
that certain constructors cannot occur for certain execution paths. \emph{Impossible}, the third 
atomic case --- \impossible{} --- is introduced for this purpose. As mentioned 
previously in Section~\ref{sec:intro}, in order to obtain this additional 
information, we perform a ``possible-constructors'' analysis simultaneously, 
which computes for each execution scenario, the subset of possible constructors 
for a given value, at a given program point. All constructors that cannot occur 
on a given execution path are marked as being \impossible. In contrast, 
constructors for which \emph{only} the tag is read are marked as $\oslash$. The 
difference between $\impossible$ and $\nothing$ can be illustrated by 
considering a polymorphic option type \emph{option<A>}, having two constructors, 
$None$ and $\mathit{Some(A \, val)}$, respectively, and a Boolean predicate that 
pattern matches on an input of this type and returns \emph{false} in the case of 
$None$ and \emph{true} in the case of $Some$, unconditioned by the value $val$ of 
its argument. For the \emph{true} execution scenario, the dependency on the 
$Some$ constructor would be $\oslash$. The tag is read and it is decisive for the 
outcome, but the value of its argument $val$ is completely irrelevant. The 
dependency on the $None$ constructor however would be $\impossible$: the 
predicate can exit with label \emph{true} if and only if the input matches 
against the $Some$ constructor. By distinguishing between these two cases we 
can not only distinguish the input's subelements that have a direct impact on an 
operation's output, but additionally, we can also obtain a more detailed 
footprint that highlights the influence exerted by the input's ``shape'' on the 
operation's outcome.

For instance, for the \disp{i}-th element of the \disp{threads} array of our 
previous example, a dependency mapping the constructor \disp{None} to $\bot$
would be a more precise approximation, when considering the label \disp{true}.
Taking into account all the discussed values, we can express the dependency 
depicted in Figure~\ref{ex:res:thread} for the label \disp{true} as follows:

\[
\left \{
\begin{array}{lll}
\mathit{threads} &\mapsto & \aexcdom{\oslash}{i}{[\mathit{Some} \mapsto \top; \mathit{None} \mapsto \bot]}\\
\mathit{pid} &\mapsto &\oslash \\
\mathit{crt\_thread} &\mapsto &\oslash \\
\mathit{adr\_space} &\mapsto &\oslash\\
\end{array}
\right\}.
\]

We remark that $\top$, $\oslash$ and $\bot$ can apply to any type. For 
instance, $\top$ can be seen as a placeholder for data that is needed in its
entirety. Structure, array or variant dependencies whose subelements are all
entirely needed and thus, uniformly mapped to $\top$, are transformed to $\top$.
The $\bot$ dependency is a placeholder for data that cannot occur on a certain
execution scenario. A whole variant value is impossible if all its constructors
are mapped to $\bot$. A whole structure or array is impossible if any of its
subelements is impossible.
 
The {\impossible} atomic value is the lower bound of our domain and hence, the 
most precise value. The final abstract dependency is a closure of all these combined 
recursively. To give an intuition of the shape of our dependency lattice, we 
illustrate below in Figure~\ref{hasse} the Hasse diagram of the order relation 
between pairs of atomic dependency values. Intuitively, if the two analyses would
be performed separately, the upper ``diamond'' shape would correspond to the 
dependency analysis, and the lower one to the possible-constructors analysis. The
$\oslash$ element would be the lower bound for the dependency domain and the upper
bound for the possible-constructors domain. By performing them simultaneously, 
$\bot$ becomes the domain's lower bound.

\begin{center}
\begin{tikzpicture}
    \node (top) at (0,0) {$(\top,\top)$};
    \node [below left  of=top] (left)  {$(\top, \oslash)$};
    \node [below right of=top] (right) {$(\oslash, \top)$};
    \node [below right of=left,yshift=-0.25cm] (middle) {$(\oslash, \oslash)$};

    \node [below left of=middle, yshift=-0.25cm] (lowerleft)  {$(\bot, \oslash)$};
    \node [below right of=middle,yshift=-0.25cm] (lowerright) {$(\oslash, \bot)$};

    \node [below right of=lowerleft] (bot) {$(\bot, \bot)$};

    \node [above right of=lowerleft, xshift=-1.5cm, yshift=-4.25] (inbetleft)  {$(\top, \bot)$};
    \node [above left of=lowerright, xshift=1.5cm, yshift=-4.25] (inbetright) {$(\bot, \top)$};

    \draw [thick, shorten <=-3pt, shorten >=-5pt, out=-120, in=90] (top) to (left);
    \draw [thick, shorten <=-3pt, shorten >=-5pt, out=-60,  in=90] (top) to (right);

    \draw [thick, shorten <=-5pt, shorten >=-3pt, out=120, in=-90] (middle) to (left);
    \draw [thick, shorten <=-5pt, shorten >=-3pt, out=60,  in=-90] (middle) to (right);

    \draw [thick, shorten <=-3pt, shorten >=-5pt, out=-120, in=90] (middle) to (lowerleft);
    \draw [thick, shorten <=-3pt, shorten >=-5pt, out=-60,  in=90] (middle) to (lowerright);

    \draw [thick, shorten <=-5pt, shorten >=-3pt, out=120, in=-90] (bot) to (lowerleft);
    \draw [thick, shorten <=-5pt, shorten >=-3pt, out=60,  in=-90] (bot) to (lowerright);

    \draw [gray, thick, shorten <=-5pt, shorten >=-3pt, out=160, in=-90] (bot) to (inbetleft);
    \draw [gray, thick, shorten <=-5pt, shorten >=-3pt, out=20,  in=-90] (bot) to (inbetright);

    \draw [gray, thick, shorten <=-5pt, shorten >=-3pt, out=100, in=-150] (inbetleft) to (left);
    \draw [gray, thick, shorten <=-5pt, shorten >=-3pt, out=80,  in=-30] (inbetright) to (right);
\end{tikzpicture}
\captionof{figure}{Order Relation on Pairs of Atomic Dependencies}
\label{hasse}
\end{center}

\subsection{Dependency flow equations}
The intraprocedural dependency analysis keeps dependency information at each point 
of the control flow graph, for each  input, output and local
variables. 

\begin{definition}{Intraprocedural Dependency Domain $\intra \in \uintra$.}\label{ch5:intradom:definition}
The \emph{intraprocedural} dependency domain $\uintra$ is defined as 
%
\[\intra \ni \uintra =  \mathcal{V} \rightarrow \udep\]
% 
An element of this domain is a mapping from variables to dependencies.
\end{definition}


Our dependency analysis is a \emph{backward} data-flow analysis. For each exit 
label, it traverses the control flow graph starting with its corresponding exit 
node and it marks all other exit points as \emph{Unreachable}, since exit labels
are mutually exclusive. The intraprocedural domain for the currently analysed 
label is initialized with its associated output variables mapped to \everything. 
Thereby, the analysis starts by making a conservative approximation and by
considering that all the input has been observed and the output depends on it 
entirely. Typically, dependence analyses are \emph{forward} analyses. However, 
given our goal to express \emph{label-specific} dependencies as input-output 
relations and taking into consideration the characteristics of the {\asmil} 
language, choosing to design our analysis as a backward data-flow analysis 
seemed a pertinent choice. In {\asmil}, outputs are associated to a particular 
exit label and they are generated if and only if the predicate exits with that 
particular label. By traversing the control flow graph backwards, we can use
this information and consider, starting with the initialisation phase, only the outputs
that are relevant for the analysed exit label.  

After the initialisation, the analysis then traverses the control flow graph and
gradually refines the dependencies until a fixed point is reached.
Table~\ref{representation} summarizes the representation and general equation of
the statements. For each statement, the presented data-flow equation operates on
the intraprocedural domains of the statement's \emph{successor} nodes. The
intraprocedural domain at the \emph{entry point} of the node is obtained by
\emph{joining} the contributions of each \emph{outgoing} edge as shown in
Figure~\ref{intra:contrib:entry}.


\definecolor{indianred}{rgb}{0.90, 0.80, 0.71} %melon
\tikzstyle{vertex} = [ellipse, fill=lightgray!50, minimum size =30pt, inner sep = 0pt]
\tikzstyle{edge} = [draw, semithick, -> ] 
\begin{figure}[hbt]\centering
\begin{tabular}{@{}c@{}}
\toprule
\begin{tikzpicture}
[scale=0.4, auto]
\node[vertex] (n1) at (10.5,14) {\phantom{switch }\Large{\textsf{statement}}\phantom{switch}}; 
\draw[edge] (10.5,16.3) -- (10.5,15.2); 
\node [above](l1) at (6.5, 16.15) {$\Delta_{in} = \;$};
%% \node [above](l9) at (14.95, 16.1) {$ \;[(\Delta_{\lambda_1}\!\setminus \textrm{\textsf{gen}})\oplus \transfer{.}{s}{\lambda_1}]\vee \ldots \vee [(\Delta_{\lambda_n}\!\setminus \textrm{\textsf{gen}})\oplus \transfer{.}{s}
%% {\lambda_n}] \;$};
\node [above](l9) at (14.95, 16.1) {$ \; \transfer{\Delta_{\lambda_1}}{s}{\lambda_1} \ijoin \ldots \ijoin
\transfer{\Delta_{\lambda_n}}{s}{\lambda_n}\;$};
\node (contrib) at (23.2, 15.2) {\small $\transfer{\Delta_i}{s}{\lambda_i} : (\Delta_i \setminus 
\textrm{\textsf{gen}}_{s, \lambda_i}) \ireduce \delta_{s,\lambda_i}$} ;
\node (line2) at (24.2, 14) {\small $\delta_{s,\lambda_i}$ contribution of $s$ on $\lambda_i$};

\draw[edge] (8.5, 12.75) -- (7.5, 9.5);
\node [below](l2) at (6.5, 11.9) {\small $\delta_{s,\lambda_1}$};
\node [above](l3) at (6.6, 9.4) {$\Delta_{\lambda_{1}}$};
\draw[edge] (12.5, 12.75) -- (13.5, 9.5);
\node [below](l6) at (10.5, 12.5) {$\ldots$};
\node [below](l4) at (14.5, 11.9) {\small $\delta_{s,\lambda_n}$};
\node [above](l5) at (14.5, 9.4) {$\Delta_{\lambda_{n}}$};
\node [below](l7) at (4.1, 12.9) {\footnotesize ($\Delta_{\lambda_1}\!\setminus \textrm{\textsf{gen}}_{s,\lambda_1}$) $\ireduce \delta_{s,\lambda_1} $};
\node [below](l8) at (17, 12.9) {\footnotesize ($\Delta_{\lambda_n}\!\setminus \textrm{\textsf{gen}}_{s,\lambda_n}$) $\ireduce \delta_{s,\lambda_n}$};
\end{tikzpicture} \\
\bottomrule
\end{tabular}
\caption{Computation of the Intraprocedural Domain at a Node's Entry Point}
\label{intra:contrib:entry}
\end{figure}

Table~\ref{generic} presents the transfer functions for statements which are not 
type-specific. For equality tests \snumber{1} both of the inputs $e_1$, $e_2$ are 
completely read, whether the test returns \lbtrue{} or \lbfalse. The transfer 
functions therefore, reduce the domain of the corresponding successor node with
a domain consisting of $e_1$ and $e_2$ both mapped to $\everything$.
%
In the case of assignment \snumber{2}, the dependency of the written output 
variable $o$ is forgotten from the successor's intraprocedural domain, thus 
being mapped to \nothing{} and forwarded to the input variable $e$.
%
The transfer function for the $\unop$ operation \snumber{3} is simply the 
identity.

\begin{longtable}{@{}c@{}}
\caption{Generic Statements -- Data-Flow Equations}
\ra{1.4}
\label{generic}
\endlastfoot
\resizebox{0.99\linewidth}{!}{
$
\begin{array}{@{}lll@{}}
\toprule
\textsf{Statement} & & \transfer {\intra}{s}{\lambda_i}
\\
\midrule
%
%Equality test
\textrm{\textsf{Equality test}}  & (1)
%
&\begin{tabular}{@{}lcccl@{}}
 $ \transfer{\intra}{e_1 = e_2}{\textrm{\lbtrue}} = \displaystyle \intra \; \ireduce\;  dep $
&&&& where 
%
\\
$\transfer{\intra}{e_1 = e_2}{\textrm{\lbfalse}} = \displaystyle \intra \; \ireduce\;  dep
    $ 
&&&&  
$ dep = \left \{ 
\begin{array} {lcl}
           e_1 & \mapsto \top \\
           e_2 & \mapsto \top
           \end{array}

  \right \} $
\\
\end{tabular}
%
\\ \\
%
%Assignment
 \textrm{\textsf{Assignment}} & (2) 
%
&  \transfer{\intra}{o:=e}{\lbtrue} =  \displaystyle \killo{}{o} \; \ireduce \; 
   \{ e \mapsto \intra(o) \}\\\\
%Nop
\textrm{\textsf{No Operation}} & (3) &\transfer{\intra}{\unop}{\lbtrue} = \intra \\\\
\bottomrule
\end{array}
$ 
}
\end{longtable}
%

The data-flow equations given in Table~\ref{structures} correspond to 
structure-related statements. For the equations \snumber{4}, \snumber{5}, 
\snumber{6} and \snumber{7} we assume that the variable $r$ is of type 
$\commonstype$ for some fields $f_i,\; 1 \leq i \leq n$. The equation \snumber{4} 
refers to the creation of a structure: each input $e_i$ is read as much as the 
corresponding field $f_i$ of the structure is read.
%
The destructuring of a structure is handled in \snumber{5}: each field $f_i$ is 
needed as much as the corresponding variable $o_i$ is.
%
When accessing the $i$-th field of a structure $r$ \snumber{6}, only the field 
$f_i$ is read, and only as much as the access' result $o$ itself. 
% 
The equation \snumber{7} treats field updates: the variable $e_i$ is read as much 
as the field $f_i$ is. The structure $r$ is read as much as all the fields other 
than $f_i$ are read in $r'$.  
%
Finally, the equations given in \snumber{8} handle partial structure equality 
tests, and the transfer functions are the same for the labels \lbtrue{} or 
\lbfalse: for both compared structures $r'$ and $r''$, all the fields in the given 
set $f_1, \ldots, f_k$ are completely read, and only those.

\begin{longtable}{@{}c@{}}
\caption{Structure-Related Statements -- Data-Flow Equations}
\ra{1.3}
\label{structures}
\endlastfoot
\resizebox{0.99\linewidth}{!}{
$
\begin{array}{@{}lcl@{}}
\toprule
 \textsf{Statement} & &  \transfer {\intra}{s}{\lambda_i} \\ 
\midrule 
%Create Structure
\textrm{\textsf{Create}} & \textrm{(4)}
&  \transfer{\intra}{\recordnew}{\textrm{\textsf{\lbtrue}}} = 
\displaystyle \killo {}{r} \; \ireduce \; \displaystyle \bigoplus_{1\leq i \leq n}\{e_i \mapsto \intra(r).f_i \}\\\\ 
% Destruct structure
\textrm{\textsf{Destructure}} & \textrm{(5)}   
& \transfer{\intra}{\recordall}{\textrm{\textsf{\lbtrue}}} =  
\displaystyle \killo {}{ \{o_i \ver o_i \in \bar{o} \}} \; \ireduce \; 
\displaystyle \{r \mapsto \{f_1 \mapsto\intra(o_1); \ldots; f_n \mapsto \intra(o_n)\}\}\\\\
% Field Access
\textrm{\textsf{Access field}} & \textrm{(6)}
&  \transfer{\intra}{\recordget}{\textrm{\textsf{\lbtrue}}} = 
\displaystyle \killo {}{o} \; \ireduce \; \{r \mapsto \{f_1 \mapsto \oslash; \ldots;  
 f_i \mapsto \intra(o); \ldots; f_n \mapsto \oslash \} \}\\\\
% Field Update
\textrm{\textsf{Update field}} & \textrm{(7)}   
&  \transfer{\intra}{\recordset}{\textrm{\textsf{\lbtrue}}} =
       \displaystyle \killo{}{r'}
             \; \ireduce \;
             \left \{
             \begin{array}{lll}
             e_i & \mapsto & \intra(r').f_i \\ 
             r & \mapsto & \left \{ \displaystyle
             f_1 \mapsto \delta_1; \ldots ; f_n \mapsto \delta_n
             \right \} 
             \end{array}
             \right \} \\\\
&& \textrm{where }             \delta_j = \left \{
                \begin{array}{ll}
                \intra(r').f_j & \textrm{if $j \neq i $} \\
                \oslash & \textrm{otherwise}\\
                \end{array} \right . \\\\
% Structure Equality
\textrm{\textsf{Equality}} & \textrm{(8)}   
& 
\begin{tabular}{@{}lccl@{}}
$\transfer{\intra}{\recordeq}{\lbtrue} = \displaystyle 
 \intra \; \ireduce \; d$  
&&& 
%\textrm{where}
$ \textrm{where } d =   \left \{
  \begin{array} {lll}
  r' & \mapsto & \displaystyle \left \{ f_1 \mapsto \delta_1; \ldots ; f_n \mapsto \delta_n  
  \right \} \\
  r'' & \mapsto & \displaystyle \left \{ f_1 \mapsto \delta_1; \ldots; f_n \mapsto \delta_n      
 \right  \}
  \end{array}
  \right \}
\;
  $ \\\\
$\transfer{\intra}{\recordeq}{\lbfalse} = \displaystyle 
 \intra \; \ireduce \; d $
&&& $\textrm{and } \delta_i =   \left \{
  \begin{array} {ll}
  \top & \textrm{if } f_i \in \{f_1, \ldots, f_k\}\\
  \oslash & \textrm{otherwise} 
  \end{array}
  \right.
\;
  $ 
\end{tabular}\\ \\
\bottomrule
\end{array}
$
}
\end{longtable}


%%% More tables for arrays and variants at line 1985 in Chapter5.tex


\subsection{Intraprocedural Dependency Analysis Illustrated}\label{sec:intra:example}

To better illustrate our analysis at an intraprocedural level, we exemplify
the mechanism behind it, step by step, on the predicate \disp{thread}, discussed
in Section~\ref{sec:intro:example}. We consider the \disp{true} execution 
scenario, apply our dependency analysis and compare the actual obtained results 
with the targeted ones depicted in Figure~\ref{ex:res:thread}.

\definecolor{indianred}{rgb}{0.90, 0.80, 0.71} %melon
\definecolor{burg}{rgb}{0.8, 0.36, 0.36}
\tikzstyle{vertex} = [ellipse, fill=lightgray!50, minimum size =30pt, inner sep = 0pt]
\tikzstyle{lvertex} = [circle, fill=lightgray!50, minimum size=30pt, inner sep=0pt]
\tikzstyle{ivertex} = [circle, draw=red, minimum size=30pt, inner sep = 0pt]
\tikzstyle{edge} = [draw, semithick, -> ] 
\tikzstyle{edgeRed} = [draw=red!50!black, dashed, thick, -> ] 
\begin{figure}[h]\centering
\begin{tabular}{@{}c@{}}
\toprule
%% \begin{tikzpicture}
%% [scale=0.6, auto]
%% \node[vertex] (n1) at (10,14) {\emph{threads := p.threads}}; 
%% \node[vertex] (n2) at (10,11) {\emph{tio := threads[i]}};
%% \node[vertex] (n3) at (10,8) {\emph{switch(tio) as [ti$\arrowvert\;$]}}; 

%% \node (n4) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(8,5.5) {\emph{true}};
%% \draw[draw=red!50!black] (8,5.5) circle(20pt); 

%% \node (n5) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(12,5.5) {\emph{None}}; 
%% \draw[draw=red!50!black] (12,5.5) circle(20pt); 

%%   \foreach \from/\to in {n1/n2,n2/n3,n3/n4,n3/n5}{
%%     \draw[edge] (\from) -- (\to); 
%%   }

%%   \draw (n2.-30) edge[semithick,->,bend left,in=120] (n5.30); 

%% \node(n8) [draw=indianred!50, fill = indianred!50, scale=0.7] at (17.5, 4) {
%% \textrm{thread(p, i) $\to$ [true: ti $\ver$ None]}}; 

%% \node(n9)[draw=burg, scale = 0.8] at (15.75,5.5) {
%% \begin{tabular}{c}
%%  $ \mathit{Unreachable} $\\
%% \end{tabular}
%% };

%% \node(d1) [draw=caribbeangreen, scale = 0.9] at (3,5.5) {
%% \begin{tabular}{c}
%% ti $\mapsto$ $\top$\\
%% \end{tabular}
%% }; 

%% \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={scale=0.7,fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {\large {th := p.threads}};
   \node[statt]         (N2) [below=1cm of N1] {\large {tio := th[i]}};
   \node[statt]         (N3) [below left=of N2] {\large {$\boldsymbol{switch}$(tio) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   \node[statt]         (N5) [below left=of N3]{\lbtrue};
   \node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge              node[xshift=-0.95cm] {\large {\lbtrue}} (N2);
   \path (N2) edge              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   \path (N2) edge              node {\large {\lbfalse}} (N4);
   \path (N3) edge              node[left, anchor=south east] {\large {\textsf{Some}}} (N5);
   \path (N3) edge              node[right, anchor=south west] {\large {\textsf{None}}} (N6);

\node(n8)[draw=burg,dotted, scale = 0.7, right=of N4, xshift=-1.6cm] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(n9)[draw=burg,dotted, scale = 0.7, right=of N6] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(d1) [draw=caribbeangreen, scale = 0.9, left=of N5] {
\begin{tabular}{c}
ti $\mapsto$ $\top$\\
\end{tabular}
}; 
\end{tikzpicture}\\
\bottomrule
\end{tabular}
\caption{Analysing Predicate \disp{thread} -- Initialisation}
\label{intra:ss:init}
\end{figure}
 
Since a predicate can only exit with one label at a time and we are considering 
the \disp{true} label, we can map the nodes \disp{None} and \disp{oob} to 
\emph{Unreachable}, as shown in Figure~\ref{intra:ss:init}. This is an advantage
of backwards analyses. For \disp{true}, we 
make a pessimistic assumption and map the output \disp{ti} to {\everything}, 
considering that control on the output is external and hence, out of our reach,
and that \disp{ti} will be entirely needed by a potential caller. Going further 
up the control flow graph, we analyse the \emph{variant switch}.

In order to compute the dependency for the node corresponding to the variant 
switch, we apply the data-flow equation, given by \snumber{10} in 
Table~\ref{variants}. Since we are analysing the \disp{true} case, we know that 
all other constructors (only the constructor \disp{None} in this case) are 
locally impossible. Thus, we map it to $\bot$. We continue by forgetting the 
dependency information we knew about the output \disp{ti}. Since its value is 
needed only in as much as the result of the switch on the corresponding edge is 
needed, we forward it to the part corresponding to the \disp{Some} constructor.
This is summarized below:

\begin{figure}[!h]\centering
\begin{tabular}{c}
%\begin{table}{@{}c@{}}
\toprule
    \begin{tikzpicture}[
      dot/.style={circle,inner sep=0pt,minimum size=1mm,fill=black},
      ]
      
      \matrix[inner sep=0pt,ampersand replacement=\&] (mtop) {
        \dottriangle{(0,0)}{1}{}{5}{4}{};\&
        \node[resetinnersep, anchor=base,yshift=-.2cm] (dots2) {$\vphantom{x}\dots\vphantom{x}$};\& 
        \coordinate (myorigin);
           \dottriangle{(0,0)}{ia}{}{5}{4}{};
        \coordinate[xshift=.15cm] (coord-ib) at (dottriangle-isep-ia.east |- myorigin);
          \node[anchor=west,inner sep=0pt] (ioplus) at (dottriangle-boundingbox-ia.east) {$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.east |- myorigin)}{ib}{green!50!black}{5}{4}{fill=green!50!black!30!white};
         {
          \node[anchor=west,inner sep=0pt,opacity=0] (ioplus) at (dottriangle-boundingbox-ia.east) {$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.east |- myorigin)}{ib}{green!50!black,opacity=0}{5}{4}{fill=green!50!black!30!white,opacity=0};
        }
        \&
        \node[resetinnersep, anchor=base,yshift=-.2cm] (dotsn1) {$\vphantom{x}\dots\vphantom{x}$};\& 
        \dottriangle{(0,0)}{n}{}{5}{4}{}; \\
      };

      % Draw bottoms on top:
        \node[fit=(dottriangle-bg-1),fill=red!20!white,inner sep=0pt,opacity=.9]  {};
        \node[green!50!black] at (dottriangle-bg-1.center) {$\bot$};
        \node[fit=(dottriangle-bg-n),fill=red!20!white,inner sep=0pt,opacity=.9]  {};
        \node[green!50!black] at (dottriangle-bg-n.center) {$\bot$};

      \draw (dottriangle-isep-1.east |- mtop.north) -- (dottriangle-isep-1.east |- mtop.south);
      \draw (dots2.east |- mtop.north) -- (dots2.east |- mtop.south);
      \draw (dottriangle-isep-ib.east |- mtop.north) -- (dottriangle-isep-ib.east |- mtop.south);
      \draw (dotsn1.east |- mtop.north) -- (dotsn1.east |- mtop.south);

      \node[resetinnersep,anchor=south,yshift=.3cm] at (dottriangle-dot-1 |- mtop.north) (num1) {\footnotesize$C_1$};
      \path ($(dottriangle-dot-ia)!.5!(dottriangle-dot-ib)$) |- node[resetinnersep,anchor=south,yshift=.3cm] (numi) {\footnotesize$C_{Some}$} (mtop.north);
      \node[resetinnersep,anchor=south,yshift=.3cm] at (dottriangle-dot-n |- mtop.north) (numn) {\footnotesize$C_n$};

      \node[inner sep=0pt,fit=(num1) (numi) (numn)] (mnum) {};
      \node[inner sep=0pt,fit=(mtop) (mnum)] (mall) {};
      
      \path[fill=black!7] (mnum.south west -| mall.west) -- (mnum.south east -| mall.east) -- (mtop.north east -| mall.east) -- (mtop.north west -| mall.west) -- cycle;
      \path (mnum.south west -| mall.west) edge[draw] (mnum.south east -| mall.east) -- (mtop.north east -| mall.east) edge[draw] (mtop.north west -| mall.west) -- cycle;
      \draw (mall.north west) -- (mall.north east) -- (mall.south east) -- (mall.south west) -- cycle;
      
      \node[anchor=base east,xshift=\defaultinnersep] (a) at (dottriangle-x-1.base -| mall.west) {$\mathit{tio} =\vphantom{x}$};
      
      \node[below left,yshift=-3mm] (o) at (mall.south west) {$\mathit{ti} =$};
      
        \dottriangle{(o.base east)}{o}{red}{5}{4}{fill=red!30!white};
        % cross out:
        \node[draw=red,cross out,inner sep=0pt,minimum width=.75cm,minimum height=.55cm,thick,opacity=.5] at (dottriangle-bg-o) {}; 
      {
        \dottriangle{(o.base east)}{o}{}{5}{4}{};
      }

        \draw (dottriangle-tc-o) edge[->,>=stealth,bend right,thick,green!30!black] (dottriangle-tc-ib);
      ;
    \end{tikzpicture}\\
  %\end{figure}

 \definecolor{indianred}{rgb}{0.8, 0.36, 0.36}

$
\colorbox{lightgray!50}{
\begin{tabular}{@{}l@{}}
$\transfer{\intra}{\varswitch}{\lambda_i} = 
\displaystyle (\intra \setminus o_i) \oplus \{ v \mapsto dep_i\}$ 
\\
where \\ 
$dep_i = [\colorbox{indianred}{$C_1 \mapsto \bot;$} \ldots; \colorbox{green!50!black!30!white}{$C_i \mapsto \intra(o_i);$} \ldots; \colorbox{indianred}{$C_n \mapsto \bot$}]$
\end{tabular}}
%\bottomrule
$ \\
\bottomrule
\end{tabular}
\caption{Applying the Variant Switch Equation}
\end{figure}

\definecolor{indianred}{rgb}{0.8, 0.36, 0.36}

\begin{figure}[h]\centering
\begin{tabular}{c}
\toprule
\resizebox{0.99\textwidth}{!}{%
%% \begin{tikzpicture}
%% [scale=0.6, auto]
%% \node[vertex] (n1) at (10,14) {\emph{threads := p.threads}}; 
%% \node[vertex] (n2) at (10,11) {\emph{tio := threads[i]}};
%% \node[vertex] (n3) at (10,8) {\emph{switch(tio) as [ti$\arrowvert\;$]}}; 

%% \node (n4) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(8,5.5) {\emph{true}};
%% \draw[draw=red!50!black] (8,5.5) circle(20pt); 

%% \node (n5) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(12,5.5) {\emph{None}}; 
%% \draw[draw=red!50!black] (12,5.5) circle(20pt); 

%%   \foreach \from/\to in {n1/n2,n2/n3,n3/n4,n3/n5}{
%%     \draw[edge] (\from) -- (\to); 
%%   }

%%   \draw (n2.-30) edge[semithick,->,bend left,in=120] (n5.30); 

%% \node(n8) [draw=indianred!50, fill = indianred!50, scale=0.7] at (17.5, 4) {
%% \textrm{thread(p, i) $\to$ [true: ti $\ver$ None]}}; 

%% \node(n9)[draw=burg, scale = 0.8] at (15.75,5.5) {
%% \begin{tabular}{c}
%%  $ \mathit{Unreachable} $\\
%% \end{tabular}
%% };

%% \node(d2) [draw=caribbeangreen, scale=0.8] at (2.5,8) {
%% \begin{tabular}{ccc}
%% tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
%% \end{tabular}
%% };

%% \node(d1) [draw=caribbeangreen, scale = 0.9] at (3,5.5) {
%% \begin{tabular}{c}
%% ti $\mapsto$ $\top$\\
%% \end{tabular}
%% }; 

%% \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={scale=0.7,fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {\large {th := p.threads}};
   \node[statt]         (N2) [below=1cm of N1] {\large {tio := th[i]}};
   \node[statt]         (N3) [below left=of N2] {\large {$\boldsymbol{switch}$(tio) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   \node[statt]         (N5) [below left=of N3]{\lbtrue};
   \node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge              node[xshift=-0.95cm] {\large {\lbtrue}} (N2);
   \path (N2) edge              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   \path (N2) edge              node {\large {\lbfalse}} (N4);
   \path (N3) edge              node[left, anchor=south east] {\large {\textsf{Some}}} (N5);
   \path (N3) edge              node[right, anchor=south west] {\large {\textsf{None}}} (N6);

\node(n8)[draw=burg,dotted, scale = 0.7, right=of N4, xshift=-1.6cm] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(n9)[draw=burg,dotted, scale = 0.7, right=of N6] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(d2) [draw=caribbeangreen, scale=0.8, left=of N3]  {
\begin{tabular}{ccc}
tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
\end{tabular}
};

\node(d1) [draw=caribbeangreen, scale = 0.9, left=of N5] {
\begin{tabular}{c}
ti $\mapsto$ $\top$\\
\end{tabular}
}; 
\end{tikzpicture}
}\\
\bottomrule
\end{tabular}
\caption{Analysing Predicate \disp{thread} -- Variant Switch}
\label{intra:ss:switch}
\end{figure}

Taking all this into account, for the node corresponding to the variant switch, 
we obtain the dependency shown in Figure~\ref{intra:ss:switch}. For the output 
\disp{ti}, we depend entirely on the \disp{Some} constructor of the node's 
input variant \disp{tio}, while the constructor \disp{None} is impossible.

Making a step further up the graph, we access the cell \disp{i} of the array 
\disp{th} and apply the equation \snumber{12} given in Table~\ref{arrays}. 
We begin by forgetting the dependency for the output \disp{tio}, 
since this is written. Since we only access the element \disp{i}, we map all 
other cells to \emph{Nothing}, i.e. $\oslash$. To the dependency corresponding 
to the \disp{i}-th cell, we forward the dependency we knew about \disp{tio}, 
since we depend on it to the extent to which the result of the access is needed.

\begin{figure}[!h]\centering
\begin{tabular}{c}
\toprule
        \begin{tikzpicture}[
      dot/.style={circle,inner sep=0pt,minimum size=1mm,fill=black},
      ]
      
      \matrix[inner sep=0pt,ampersand replacement=\&] (mtop) {
        \dottriangle{(0,0)}{1}{}{5}{4}{};
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (1oplus) at (dottriangle-boundingbox-1.east) 
            {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (1oplus) at (dottriangle-boundingbox-1.east) 
{$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \&
        \node[resetinnersep, anchor=base,yshift=-.2cm] (dots2) {$\vphantom{x}\dots\vphantom{x}$};\& 
        \coordinate (myorigin);
        \dottriangle{(0,0)}{ia}{}{5}{4}{};
        %\alt<3->{
          \node[anchor=west,inner sep=0pt] (ioplus) at (dottriangle-boundingbox-ia.east) 
            {$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.east |- myorigin)}{ib}{green!50!black}{5}{4}{fill=green!50!black!30!white};
        {
          \node[anchor=west,inner sep=0pt,opacity=0] (ioplus) at (dottriangle-boundingbox-ia.east) 
{$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.east |- myorigin)}{ib}{green!50!black,opacity=0}{5}{4}{fill=green!50!black!30!white,opacity=0};
        }\&
        \node[resetinnersep, anchor=base,yshift=-.2cm] (dotsn1) {$\vphantom{x}\dots\vphantom{x}$};\& 
        % \dottriangle{(0,0)}{n1}{}{5}{4}{}; \&
        \dottriangle{(0,0)}{n}{}{5}{4}{};
       
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (noplus) at (dottriangle-boundingbox-n.east) 
            {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (noplus) at (dottriangle-boundingbox-n.east) 
{$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \\
      };
      
      \draw (1oplus.east |- mtop.north) -- (1oplus.east |- mtop.south);
      \draw (dots2.east |- mtop.north) -- (dots2.east |- mtop.south);
      \draw (dottriangle-isep-ib.east |- mtop.north) -- (dottriangle-isep-ib.east |- mtop.south);
      \draw (dotsn1.east |- mtop.north) -- (dotsn1.east |- mtop.south);

      \node[resetinnersep,anchor=south] at (dottriangle-dot-1 |- mtop.north) (num1) {\footnotesize$1$};
      \path ($(dottriangle-dot-ia)!.5!(dottriangle-dot-ib)$) |- node[resetinnersep,anchor=south] (numi) {\footnotesize$i$} (mtop.north);
      \node[resetinnersep,anchor=south] at (dottriangle-dot-n |- mtop.north) (numn) {\footnotesize$n$};

      \node[inner sep=0pt,fit=(num1) (numi) (numn)] (mnum) {};
      \node[inner sep=0pt,fit=(mtop) (mnum),draw] (mall) {};
      
      \draw (mtop.north west) -- (mtop.north east);
      
      \node[anchor=base east,xshift=\defaultinnersep] (a) at (dottriangle-x-1.base -| mall.west) {$\mathit{th} =\vphantom{x}$};
      
      \node[below left,yshift=-3mm] (o) at (mall.south west) {$\mathit{tio} =$};
      
        \dottriangle{(o.base east)}{o}{red}{5}{4}{fill=red!30!white};
        % cross out:
        \node[draw=red,cross out,inner sep=0pt,minimum width=.75cm,minimum height=.55cm,thick,opacity=.5] at (dottriangle-bg-o) {};
      {
        \dottriangle{(o.base east)}{o}{}{5}{4}{};
      }

% {
          \node[draw=red,cross out,inner sep=0pt,minimum width=.75cm,minimum height=.55cm,thick,opacity=0] at (dottriangle-bg-ia) {};

        \draw (dottriangle-tc-o) edge[->,>=stealth,bend right,thick,green!30!black] (dottriangle-tc-ib);
      ;
    \end{tikzpicture}\\


\resizebox{0.95\textwidth}{!}{
\colorbox{lightgray!50}{
$\transfer{\intra}{\arrayget}{\lbtrue} = \displaystyle
 \left \lgroup
               \begin {array}{ll}
                \colorbox{indianred}{$\killo{}{o} $}\; \oplus \;
                \left \{
                \begin{array}{lll}
                i & \mapsto & \top \\%{green!50!black!30!white}
                a & \mapsto & \colorbox{green!50!black!30!white}{$\langle \oslash \; \triangleright \; i: \intra(o) \rangle$}
                \end{array} \right \} 
               & \begin{array}{l}
                 \textrm{when $ i \in \inputs \;$} \\                
                 \end{array}
       \\ \\
                \colorbox{indianred}{$\killo{}{o}$} \; \oplus \; 
                \left \{
                \begin{array} {lll}
                 i & \mapsto & \top \\
                 a & \mapsto &\colorbox{green!50!black!30!white}{$ \langle \intra(o) \vee \oslash \rangle$}
                 \end{array}
                \right \} 
               & \begin{array}{l}
                 \textrm {when $ i \notin \inputs \;$} \\                 
                 \end{array}
              \\
               \end{array} \right.
 $
}}\\
\bottomrule
\end{tabular}
\caption{Applying the Array Access Equation}
\label{fig:eq:array}
\end{figure}

We thus obtain a dependency stating that we depend only on the \disp{i}-th 
cell of the array \disp{th}, for which only the constructor \disp{Some} is 
possible and entirely needed. The cell's index \disp{i} is entirely needed as 
well. The applied equation is shown in Figure~\ref{fig:eq:array} (since \disp{i}
is an input, we use the first case of the equation) and the 
obtained results are shown in Figure~\ref{intra:ss:array}. 

\begin{figure}[h]\centering
\begin{tabular}{@{}c@{}}
\toprule
\resizebox{0.99\textwidth}{!}{%
%% \begin{tikzpicture}
%% [scale=0.6, auto]
%% \node[vertex] (n1) at (10,14) {\emph{threads := p.threads}}; 
%% \node[vertex] (n2) at (10,11) {\emph{tio := threads[i]}};
%% \node[vertex] (n3) at (10,8) {\emph{switch(tio) as [ti$\arrowvert\;$]}}; 

%% \node (n4) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(8,5.5) {\emph{true}};
%% \draw[draw=red!50!black] (8,5.5) circle(20pt); 

%% \node (n5) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(12,5.5) {\emph{None}}; 
%% \draw[draw=red!50!black] (12,5.5) circle(20pt); 

%%   \foreach \from/\to in {n1/n2,n2/n3,n3/n4,n3/n5}{
%%     \draw[edge] (\from) -- (\to); 
%%   }

%%   \draw (n2.-30) edge[semithick,->,bend left,in=120] (n5.30); 

%% \node(n8) [draw=indianred!50, fill = indianred!50, scale=0.7] at (17.5, 4) {
%% \textrm{thread(p, i) $\to$ [true: ti $\ver$ None]}}; 

%% \node(n9)[draw=burg, scale = 0.8] at (15.75,5.5) {
%% \begin{tabular}{c}
%%  $ \mathit{Unreachable} $\\
%% \end{tabular}
%% };

%% \node(d3) [draw=caribbeangreen, scale=0.8] at (1.4,10.8) {
%% \begin{tabular}{cll}
%% threads & $\mapsto $
%% & $\langle \oslash\;\; \triangleright\;$  i: [Some $\mapsto \top$; None $\mapsto \bot$] $\rangle$  \\

%% i & $\mapsto$ &$\top$\\
%% \end{tabular}
%% };

%% \node(d2) [draw=caribbeangreen, scale=0.8] at (2.5,8) {
%% \begin{tabular}{ccc}
%% tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
%% \end{tabular}
%% };

%% \node(d1) [draw=caribbeangreen, scale = 0.9] at (3,5.5) {
%% \begin{tabular}{c}
%% ti $\mapsto$ $\top$\\
%% \end{tabular}
%% }; 

%% \end{tikzpicture}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={scale=0.7,fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {\large {th := p.threads}};
   \node[statt]         (N2) [below=1cm of N1] {\large {tio := th[i]}};
   \node[statt]         (N3) [below left=of N2] {\large {$\boldsymbol{switch}$(tio) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   \node[statt]         (N5) [below left=of N3]{\lbtrue};
   \node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge              node[xshift=-0.95cm] {\large {\lbtrue}} (N2);
   \path (N2) edge              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   \path (N2) edge              node {\large {\lbfalse}} (N4);
   \path (N3) edge              node[left, anchor=south east] {\large {\textsf{Some}}} (N5);
   \path (N3) edge              node[right, anchor=south west] {\large {\textsf{None}}} (N6);

\node(n8)[draw=burg,dotted, scale = 0.7, right=of N4, xshift=-1.6cm] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(n9)[draw=burg,dotted, scale = 0.7, right=of N6] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(d3) [draw=caribbeangreen, scale=0.8, left=of N2] {
\begin{tabular}{cll}
th & $\mapsto $
& $\langle \oslash\;\; \triangleright\;$  i: [Some $\mapsto \top$; None $\mapsto \bot$] $\rangle$  \\
i & $\mapsto$ &$\top$\\
\end{tabular}
};

\node(d2) [draw=caribbeangreen, scale=0.8, left=of N3]  {
\begin{tabular}{ccc}
tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
\end{tabular}
};

\node(d1) [draw=caribbeangreen, scale = 0.9, left=of N5] {
\begin{tabular}{c}
ti $\mapsto$ $\top$\\
\end{tabular}
}; 
\end{tikzpicture}
}\\
\bottomrule
\end{tabular}
\caption{Analysing Predicate \disp{thread} -- Array Access}
\label{intra:ss:array}
\end{figure}

As a last step, we access the field \disp{threads} of the input process \disp{p}
and apply the equation \snumber{6} given in Table~\ref{structures} and illustrated in
Figure~\ref{intra:ss:faccess}.
As before, we forget the information for \disp{th}, the access result. We 
map all other fields to $\oslash$ and we forward the dependency of the variable 
\disp{th} to the dependency part of the field \disp{threads}.

\begin{figure}[!h]
\begin{tabular}{c}
\toprule
   % \centering   
    \begin{tikzpicture}[
      dot/.style={circle,inner sep=0pt,minimum size=1mm,fill=black},
%      every node/.style={draw=black!50!white}
      ]
      
      \matrix[inner sep=0pt,ampersand replacement=\&] (mtop) {
        \node[resetinnersep,] (f1) {$f_1=$}; \dottriangle{(f1.base east)}{1}{}{3}{4}{};
        %\alt<3->{
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (1oplus) at (dottriangle-boundingbox-1.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (1oplus) at (dottriangle-boundingbox-1.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \&
        \&
        \node[resetinnersep,] (f2) {$f_2=$}; \dottriangle{(f2.base east)}{2}{}{5}{4}{};
        %\alt<3->{
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (2oplus) at (dottriangle-boundingbox-2.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (2oplus) at (dottriangle-boundingbox-2.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \\
      };
      
      \matrix[inner sep=0pt,below=0cm of mtop, ampersand replacement=\&] (mmid) {
        \node[resetinnersep,] (fi) {$f_{threads}=\vphantom{x}$};
        % \alt<2->{
        % \dottriangle{([xshift=-\defaultinnersep]fi.base east)}{ia}{}{5}{3}{fill=red!30!white};
        % }{
        \dottriangle{([xshift=-\defaultinnersep]fi.base east)}{ia}{}{3}{5}{};
        % }
          \node[anchor=base west,inner sep=0pt] (ioplus) at (dottriangle-boundingbox-ia.east |- fi.base) {$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.base east)}{ib}{green!50!black}{3}{5}{fill=green!50!black!30!white};
        {
          \node[anchor=base west,inner sep=0pt,opacity=0] (ioplus) at (dottriangle-boundingbox-ia.east |- fi.base) {$\vphantom{x}\mathbin{\oplus}\vphantom{x}\;$};
          \dottriangle{(ioplus.base east)}{ib}{green!50!black,opacity=0}{3}{5}{fill=green!50!black!30!white,opacity=0};
        }\\
      };

      \matrix[inner sep=0pt,below=0cm of mmid,ampersand replacement=\&] (mbot) {
        \node[resetinnersep,] (fn1) {$f_{n-1}=$}; \dottriangle{(fn1.base east)}{n1}{}{4}{3}{};
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (n1oplus) at (dottriangle-boundingbox-n1.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (n1oplus) at (dottriangle-boundingbox-n1.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \&
        \node[resetinnersep,] (fn) {$f_{n}=$}; \dottriangle{(fn.base east)}{n}{}{4}{5}{};
        %\alt<3->{
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm] (noplus) at (dottriangle-boundingbox-n.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        {
          \node[anchor=west,inner sep=1.3mm,xshift=-1.3mm,opacity=0] (noplus) at (dottriangle-boundingbox-n.east)
          {$\vphantom{x}\mathbin{\oplus}\textcolor{green!50!black}{\oslash}$};
        } \\
      };
      
      \node[inner sep=0pt,fit=(mtop) (mmid) (mbot),draw] (mall) {};
      \draw (mtop.south -| mall.west) -- (mtop.south -| mall.east);
      \draw (mmid.south -| mall.west) -- (mmid.south -| mall.east);
      % \draw (f2.west |- mtop.north) -- (f2.west |- mtop.south);
      \draw (1oplus.east |- mtop.north) -- (1oplus.east |- mtop.south);
      % \draw (fn.west |- mbot.north) -- (fn.west |- mbot.south);
      \draw (n1oplus.east |- mbot.north) -- (n1oplus.east |- mbot.south);

      \node[anchor=base east,xshift=\defaultinnersep] (s) at (f1.base -| mall.west) {$p =\vphantom{x}$};
      
      \node[below left,yshift=-3mm] (o) at (mall.south west) {$th =$};
      
     
        \dottriangle{(o.base east)}{o}{red}{3}{5}{fill=red!30!white};
        % cross out:
        \node[draw=red,cross out,inner sep=0pt,minimum size=.55cm,thick,opacity=.5] at (dottriangle-bg-o) {};
      {
        \dottriangle{(o.base east)}{o}{}{3}{5}{};
      }

        \draw (dottriangle-tc-o) edge[->,>=stealth,bend right,thick,green!30!black] (dottriangle-tc-ib);
      
    \end{tikzpicture}\\

\colorbox{lightgray!50}{
$\transfer{\intra}{\recordget}{\textrm{\textsf{\lbtrue}}} = 
\displaystyle 
\colorbox{indianred} {$\killo {}{o}$} 
\; \oplus \; \{s \mapsto \{f_1 \mapsto \oslash; \ldots;  
\colorbox{green!50!black!30!white} {$f_i \mapsto \intra(o);$} 
\ldots; f_n \mapsto \oslash \} \} 
$
}\\
\bottomrule
\end{tabular}
\caption{Applying the Field Access Equation}
\label{intra:ss:faccess}
\end{figure} 

We thus obtain the dependency result shown in Figure~\ref{intra:ss:struct}. 
This states that for the label \disp{true}, the output \disp{ti} depends only on 
the \disp{i}-th cell of the field \disp{threads} of the input process \disp{p}, 
for which it depends entirely on the \disp{Some} constructor. Before returning
the predicate's final results, the analysis filters out any dependency 
information referring to local variables and verifies that the invariant imposed 
on dependency information related to arrays holds. Since the results refer only
to the inputs \disp{p} and \disp{i} and the index of the exceptional computed
dependency is an input, the invariant holds and the final result can be retrieved.
The final dependency results obtained for the \disp{thread} predicate on the exit
label \disp{true} are identical to the ones that we were targeting and that were
depicted in Figure~\ref{ex:res:thread}. For readability considerations, for 
structures such as the input process \disp{p}, we omit dependencies on fields
mapped to $\oslash$. We maintain this convention throughout the rest of this 
chapter, and thus any field of a structure that is omitted from a dependency
summary should be interpreted as being mapped to $\oslash$, i.e. \emph{nothing}.  

%de sters
%pana aici

\begin{figure}[htbp]\centering
\begin{tabular}{c}
\toprule
\resizebox{0.99\textwidth}{!}{%
%% \begin{tikzpicture}
%% [scale=0.6, auto]
%% \node[vertex] (n1) at (10,14) {\emph{threads := p.threads}}; 
%% \node[vertex] (n2) at (10,11) {\emph{tio := threads[i]}};
%% \node[vertex] (n3) at (10,8) {\emph{switch(tio) as [ti$\arrowvert\;$]}}; 

%% \node (n4) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(8,5.5) {\emph{true}};
%% \draw[draw=red!50!black] (8,5.5) circle(20pt); 

%% \node (n5) [draw=red!50!black, circle,fill=lightgray!50, minimum size=30pt, inner sep =0pt] at(12,5.5) {\emph{None}}; 
%% \draw[draw=red!50!black] (12,5.5) circle(20pt); 

%%   \foreach \from/\to in {n1/n2,n2/n3,n3/n4,n3/n5}{
%%     \draw[edge] (\from) -- (\to); 
%%   }

%%   \draw (n2.-30) edge[semithick,->,bend left,in=120] (n5.30); 

%% \node(n8) [draw=indianred!50, fill = indianred!50, scale=0.7] at (17.5, 4) {
%% \textrm{thread(p, i) $\to$ [true: ti $\ver$ None]}}; 

%% \node(n9)[draw=burg, scale = 0.8] at (15.75,5.5) {
%% \begin{tabular}{c}
%%  $ \mathit{Unreachable} $\\
%% \end{tabular}
%% };

%% \node(d4) [draw=caribbeangreen, scale=0.7] at (0.6, 14) {
%% \begin{tabular}{lll}
%% p & $\mapsto $
%% & \{ threads $\mapsto$ $\langle \oslash\;\; \triangleright\; $ i:   
%% [Some $\mapsto \top$; \textrm{None $\mapsto \bot$}]$\rangle\}$ \\
%% i & $\mapsto$ & $\top$ \\
%% \end{tabular}
%% };

%% \node(d3) [draw=caribbeangreen, scale=0.8] at (1.4,10.8) {
%% \begin{tabular}{cll}
%% threads & $\mapsto $
%% & $\langle \oslash\;\; \triangleright\;$  i: [Some $\mapsto \top$; None $\mapsto \bot$] $\rangle$  \\

%% i & $\mapsto$ &$\top$\\
%% \end{tabular}
%% };

%% \node(d2) [draw=caribbeangreen, scale=0.8] at (2.5,8) {
%% \begin{tabular}{ccc}
%% tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
%% \end{tabular}
%% };

%% \node(d1) [draw=caribbeangreen, scale = 0.9] at (3,5.5) {
%% \begin{tabular}{c}
%% ti $\mapsto$ $\top$\\
%% \end{tabular}
%% }; 

%% \end{tikzpicture}

 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={scale=0.7,fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm}]
%
   \node[statt]         (N1)  {\large {th := p.threads}};
   \node[statt]         (N2) [below=1cm of N1] {\large {tio := th[i]}};
   \node[statt]         (N3) [below left=of N2] {\large {$\boldsymbol{switch}$(tio) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   \node[statt]         (N5) [below left=of N3]{\lbtrue};
   \node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge              node[xshift=-0.95cm] {\large {\lbtrue}} (N2);
   \path (N2) edge              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   \path (N2) edge              node {\large {\lbfalse}} (N4);
   \path (N3) edge              node[left, anchor=south east] {\large {\textsf{Some}}} (N5);
   \path (N3) edge              node[right, anchor=south west] {\large {\textsf{None}}} (N6);

\node(n8)[draw=burg,dotted, scale = 0.7, right=of N4, xshift=-1.6cm] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(n9)[draw=burg,dotted, scale = 0.7, right=of N6] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(d4) [draw=caribbeangreen, scale=0.7, left=of N1] {
\begin{tabular}{lll}
p & $\mapsto $
& \{ threads $\mapsto$ $\langle \oslash\;\; \triangleright\; $ i:   
[Some $\mapsto \top$; \textrm{None $\mapsto \bot$}]$\rangle\}$ \\
i & $\mapsto$ & $\top$ \\
\end{tabular}
};

\node(d3) [draw=caribbeangreen, scale=0.8, left=of N2] {
\begin{tabular}{cll}
th & $\mapsto $
& $\langle \oslash\;\; \triangleright\;$  i: [Some $\mapsto \top$; None $\mapsto \bot$] $\rangle$  \\

i & $\mapsto$ &$\top$\\
\end{tabular}
};

\node(d2) [draw=caribbeangreen, scale=0.8, left=of N3]  {
\begin{tabular}{ccc}
tio & $\mapsto$ & [Some $\mapsto \top$; None $\mapsto \bot$]  \\
\end{tabular}
};

\node(d1) [draw=caribbeangreen, scale = 0.9, left=of N5] {
\begin{tabular}{c}
ti $\mapsto$ $\top$\\
\end{tabular}
}; 
\end{tikzpicture}
}\\
\bottomrule
\end{tabular}
\caption{Analysing Predicate \disp{thread} -- Field Access}
\label{intra:ss:struct}
\end{figure}


\subsection{An inter-procedural extension}

\section{Correlation analysis}
\input{correlation-macros}

Recall from Section~\ref{sec:methodology} that our overall methodology
for tackling the frame problem consists in combining a dependency
analysis with a correlation analysis, that identifies what part of the
input is copied to the output without being modified. 
%
In this section, we present a static 
\emph{correlation} analysis which, when given a predicate that manipulates a 
structured input, determines automatically the subset of the input that remains 
unchanged and is further propagated into the output. Thus, the behaviour of a
predicate is summarised by computing relations between parts of the input and 
parts of the output. 

%The computed \emph{correlation summaries} are a safe 
%approximation of what part of an input state of a predicate is copied to the 
%output state. 

The correlation analysis is a conservative static analysis inferring what is 
modified by an operation and to what extent. It approximates the flow of input 
values into output values, by uncovering \emph{equalities} and computing 
\emph{correlations} as pairs between input parts and the output parts
into which  these are injected. What is marked as being equal is
definitely equal. As equalities iin general only pertain to parts of a data
structure, we shall formalize them as \emph{partial equivalence
relations} on structured data. 

\begin{figure}[!h]
\minipage[c]{\textwidth}
\centering
  \centering
  \begin{forest}
    oni tree defaults,
    [, % Start directly with a comma: no node contents
     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
     s sep=3.5cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
     %
     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
    %First 
    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.15cm},% start squiggly tree,
        [,zag=6mm,
          [;$\pi$, zig=3mm, 
            [,name=o1, zag=3mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.01cm, iburg,}, %pattern=north east lines, pattern color=iburg},
               [, name=d1, invisible tree,
             ]
            ]
          ]
        ]
        [,zig=5mm,
          [,zag=2mm,
            [, zig=1mm, 
                [;$\rho$,name=g1, zag=2mm,triangle fit whole subtree={triangle sep=0.5mm, bottom space=0.01cm,draw=caribbeangreen, fill=caribbeangreen},
                  [, invisible tree,
                  ]
              ]
            ]
          ]
        ]
      ]
 %Second
     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.1cm},% start squiggly tree,
        [,zag=8mm
          [, zig=2mm, 
            [,name=ax2, zag=7mm, 
             [,zig =2mm, 
               [;$\pi'$, name=o2, zag=6mm,triangle fit whole subtree={triangle sep=1mm, bottom space=0.01cm,thick, iburg},  
               [, name=d2, invisible tree,
               ]
              ]
             ]
            ]
          ]
        ]
       [,zig=4mm
          [, zag=2mm, 
            [;$\rho'$,name=g2, zig=1mm, triangle fit whole subtree={triangle sep=0.5mm, bottom space=0.01cm, draw=caribbeangreen, fill=caribbeangreen},
               [, invisible tree,
               ]
            ]
          ]
       ]
      ]
    ]
   \draw[<->, shorten=2pt, thick, caribbeangreen] (g1) edge[bend left] node[above]{$\rel'$} (g2);
   \draw[<->, shorten=2pt, thick, iburg] (o1) edge[bend right, out=60] node[below]{$\rel$} (o2);
  \end{forest}
\endminipage\hfill
\caption{Intraprocedural Correlations -- General Representation}
\label{cor:fig:intra}
\end{figure}

Outputs are often complex compounds of different subparts of different
input variables: a subset of the input is modified, while the rest is
injected as is.  We track the origin of subparts of the output and
relate it to subparts of the input. As previously illustrated on our
\disp{stop_thread} example predicate, in order to prevent avoidable
over-approximations, we need to avoid dealing with data in a
monolithic manner. To this end, it is imperative to consider pairs of
different types and granularities as well. As a consequence, we are
forced to introduce an additional level of granularity allowing us to
refer not only to variables, but also to substructures within them. At
the intraprocedural level, illustrated in Figure~\ref{cor:fig:intra},
we define correlations as mappings between pairs of inputs and outputs
to which we associate mappings between pairs of valid inner paths and
the relations binding them. Correlations for arrays and variants are
exemplified in 
Figures~\ref{fig:cor:examples}-a)~and~\ref{fig:cor:examples}-b).

\begin{figure}[!hbt]\centering
\begin{tabular}{@{}cc@{}}
\toprule
\minipage{0.38\textwidth}
 \centering
  \begin{tikzpicture}[thick,scale=0.5, every node/.style={scale=0.5}]
    % \node[shape=multipart rectangle,parts=2] {a\second b};
    \matrix[matrix of nodes, row sep=0pt, column sep=0pt] (m) {
      \phantom{i} &
      \phantom{i} &
      |[fill=gray!20!white,alias=mi]| \large{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} \\
    };

    \draw (m-1-1.north west) -- (m-1-8.north east) -- (m-1-8.south east) -- (m-1-1.south west) -- cycle;
    \foreach \i in {1,...,7} {% 8 - 1 to not have double line on the last cell.
      \draw (m-1-\i.north east) -- (m-1-\i.south east);
    }

    \matrix[matrix of nodes, row sep=0pt, column sep=0pt, right=0.5cm of m] (n) {
      \phantom{i} &
      \phantom{i} &
      |[fill=gray!20!white,alias=ni]| \large{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} &
      \phantom{i} \\
    };

    \draw (n-1-1.north west) -- (n-1-8.north east) -- (n-1-8.south east) -- (n-1-1.south west) -- cycle;
    \foreach \i in {1,...,7} {% 8 - 1 to not have double line on the last cell.
      \draw (n-1-\i.north east) -- (n-1-\i.south east);
    }
    
    \def\braceAmplitude{6pt}
    \def\braceRaise{2pt}
    
    % decoration={,mirror,} to have the brace the other way round
    \draw (m-1-1.south west) edge[decorate,decoration={brace,amplitude=\braceAmplitude,raise=\braceRaise,mirror}] node[coordinate,yshift=8pt] (mx) {} (m-1-8.south east);
    \draw (n-1-1.south west) edge[decorate,decoration={brace,amplitude=\braceAmplitude,raise=\braceRaise,mirror}] node[coordinate,yshift=8pt] (nx) {} (n-1-8.south east);

    % \draw (mi.south) edge[<->,>=stealth,looseness=.5,out=-70,in=-110,shorten <=1.5pt, shorten >=1.5pt] node[below]{\large$\mathcal{R}$} (ni.south);
    \draw ([yshift=-1cm]mx) edge[<->,>=stealth,looseness=.5,out=-70,in=-110] node[below]{\large$\rel$} ([yshift=-1cm]nx);
    
    % Background:
    \path[fill=white,opacity=.3]
      ($(mi.north west) + (0, \braceAmplitude*0.5+\braceRaise) + (0,1pt)$)
      rectangle
      ($(mi.north east) + (0, \braceAmplitude*0.5+\braceRaise) - (0,1pt)$);
        
    \coordinate (miX) at ($(mi.north west) + (0, \braceAmplitude*0.5+\braceRaise) + (1pt,0)$);
    \coordinate (miY) at ($(mi.north east) + (0, \braceAmplitude*0.5+\braceRaise) - (.5pt,0)$);

    % \foreach \i in {0,0.2,...,1} {
    %   \draw[black!70] ($(miX)!\i!(miY)-(1pt,1pt)$) -- ($(miX)!\i!(miY)+(1pt,1pt)$);
    % }
 
    %%%%

    % Background:
    \path[fill=white,opacity=.3]
      ($(ni.north west) + (0, \braceAmplitude*0.5+\braceRaise) + (0,1pt)$)
      rectangle
      ($(ni.north east) + (0, \braceAmplitude*0.5+\braceRaise) - (0,1pt)$);

    \coordinate (niX) at ($(ni.north west) + (0, \braceAmplitude*0.5+\braceRaise) + (1pt,0)$);
    \coordinate (niY) at ($(ni.north east) + (0, \braceAmplitude*0.5+\braceRaise) - (.5pt,0)$);
  \end{tikzpicture}

\endminipage
\minipage{0.35\textwidth}
  \centering
  \begin{tikzpicture}  [thick,scale=0.55, every node/.style={scale=0.55}]
  \pgfmathsetseed{\rndseed}
  \triangleArray{n}{(0,0)}

  \pgfmathsetseed{\rndseed}
  \triangleArray{m}{($(n-0.south west) + (.5cm,-1cm)$)}
  
  % Arrows:
  \foreach \i in {0,...,\nbnodes} {%
    % Centers: tc
    % Top: tt, left: tl, right: tr, bottom: tb
    \draw (n-tb-\i) edge[<->,>=stealth,out=-90,in=90, shorten <=.5pt, shorten >=.5pt] (m-tt-\i);
  }
  
  \end{tikzpicture}
\endminipage%
\\
\hspace{-0.1\textwidth}\minipage{0.48\textwidth}
\centering\small a) Arrays: $\;\forall i, \;  a{\left[i\right]} \mathbin{\rel} b{\left[i\right]}$
\endminipage\hspace{-0.1\textwidth}
\minipage{0.25\textwidth}
\centering\small b) Variants
\endminipage
\\
\bottomrule
\end{tabular}
\caption{Intraprocedural Domain -- Examples}
\label{fig:cor:examples}
\end{figure}

Similarly to our dependency analysis presented in Chapter~\ref{chapter5}, the
correlation analysis is an interprocedural, flow-sensitive, field-sensitive, 
label-sensitive analysis that handles associative arrays, structures and variant 
data types. However, unlike the dependency analysis for which we introduced a 
relaxed form of context-sensitivity in Chapter~\ref{chapter6}, the correlation 
analysis is context-insensitive. Fine-grained equivalence relations between the
inputs and outputs of a predicate are computed once and subsequently propagated
to its callers.  

Our correlation analysis is meant to be used in an interactive verification 
context. Precise correlation summaries must be computed quickly in order to 
answer effectively, when combined with dependency summaries, queries 
regarding the preservation of certain invariants. 


\subsection{Correlations as partial equivalence relations}

The first step towards automatically reasoning about the propagation of input
subelements into output subelements is the definition of an abstract 
\emph{partial equivalence type} $\rdom$ that mimics the structure of algebraic 
data types and arrays. A partial equivalence relation $\rel \in \rdom$ is defined 
inductively from the two atomic elements, {\equal} and \qmark, and mirrors the 
structure of the concrete types. 

\begin{definition}\label{corpertyppe}
{Partial Equivalence Type $\rel \in \rdom$.}
\[
\begin{array}{lllr}
 \rel :=  &\ver \equal                &\; \textrm{atomic case -- equal} &\snumber{i}\\
          &\ver \qmark                &\; \textrm{atomic case -- unrelated} & \snumber{ii}\\
          & \mathit{\ver \rels}
          & \; \mathit{f_1, \ldots, f_n}  \textrm{  fields} & \snumber{iii}\\
          & \ver \mathit{\relv} 
          & \; C_1, \ldots, C_n  \textrm{  constructors} & \snumber{iv}\\
          & \mathit{\ver \arel{\rel_{def}}} &\textrm{  array} & \textrm{\scriptsize(v)} \\
          & \mathit{\ver \relai} 
          & \; \mathit{i} \; \textrm{array index} & \textrm{\scriptsize(vi)} 
\end{array} 
\]
\end{definition}

\noindent Such relations represent fine-grained partial equivalences between
pairs of values of the same type. {\equal} and {\qmark} represent equal and
unrelated values, respectively. Partial equivalence relations for structures
(given by (iii)) and for variants (given by (iv)), are expressed in terms of the
partial equivalences of their subparts, by mapping each field or constructor to
the corresponding relations. As for the dependency analysis presented in
Chapter~\ref{chapter5}, for arrays, we distinguish between two cases, namely
arrays with a general relation applying to all of the cells (as given by (v)) or
to all but one exceptional cell (as given by (vi)), for which a specific
relation is known to hold.

The preorder relation of the partial equivalence lattice is denoted by 
$\rleq$ and defined below.
\begin{definition}{Preorder Relation $\rleq$.}\label{ch7:preorderper:definition}
\[
  {\rleq}  \subseteq \rdom \times \rdom.
\]
\end{definition}
\noindent It is detailed in Table~\ref{rleq}.

\begin{table}[hbtp]
\centering
\caption{$\rleq$ -- Comparison of Two Domains}
\label{rleq}
\begin{tabular}{@{}c@{}}
\toprule \\

$\inferrule*[right=Top]
{\phantom{a}}
{\rel \rleq \qmark}

\;\;\;\;

\inferrule*[right=Bot]
{\phantom{a}}
{\equal \rleq \rel}
$
\\\\

$\inferrule*[right=Str]
{\rel_1 \rleq \rel'_1 \\ \ldots \\ \rel_n \rleq \rel'_n}
{\rels \rleq \srelv{f}{n}{\rel'}}
$
\\\\

$\inferrule*[right=Var]
{\rel_1 \rleq \rel'_1 \\ \ldots \\ \rel_n \rleq \rel'_n}
{\relv \rleq \vrelv{C}{n}{\rel'}}
$
\\\\

$\inferrule*[right=Adef]
{\rel \rleq \rel'}
{\rela \rleq \arel{\rel'}}

\;\;\;\;

\inferrule*[right=AI]
{\rel_{\mathit{def}} \rleq \rel'_{\mathit{def}} \\ \rel_{\mathit{exc}} \rleq \rel'_{\mathit{exc}}}
{\relai \rleq \aerel{\rel'_{\mathit{def}}}{i}{\rel'_{\mathit{exc}}}}
$
\\\\

$\inferrule*[right=AIA]
{\rel_{\mathit{def}} \rleq \rel' \\ \rel_{\mathit{exc}} \rleq \rel'}
{\relai \rleq \arel{\rel'}}

\;\;\;\;

\inferrule*[right=AAI]
{\rel \rleq \rel'_{\mathit{def}} \\ \rel \rleq \rel'_{\mathit{exc}}}
{\rela \rleq \aerel{\rel'_{\mathit{def}}}{i}{\rel'_{\mathit{exc}}}}
$
\\\\

$\inferrule*[right=AIJ]
{i \neq j \\ \rel_{\mathit{def}} \rleq \rel'_{\mathit{def}} \\ \rel_{\mathit{def}} \rleq \rel'_{\mathit{exc}} \\ \rel_{\mathit{exc}} \rleq \rel'_{\mathit{def}} \\ \rel_{\mathit{exc}} \rleq \rel'_{\mathit{exc}}}
{\relai \rleq \aerel{\rel'_{\mathit{def}}}{j}{\rel'_{\mathit{exc}}}}
$ 
\\\\
\bottomrule
\end{tabular}
\end{table}

The \emph{join} and \emph{meet} operations are denoted by $\rjoin$ and $\rmeet$,
respectively.
\begin{definition}{Join Operation $\rjoin$.}\label{ch7:joinoperationper:definition}
\[
 \rjoin\;  : \;\rdom\; \times \;\rdom\; \to \;\rdom. %\;\;\;\;\;\;  
% \rmeet  : \rdom \; \times \rdom \; \to \rdom 
\]
\end{definition}

\begin{definition}{Meet Operation $\rmeet$.}\label{ch7:meetoperationper:definition}
\[
\rmeet\;  : \;\rdom \; \times \;\rdom \; \to \;\rdom. 
\]
\end{definition}

\noindent Both are \emph{commutative} 
operations, applied pointwise on each subelement. \emph{Join}, shown in 
Table~\ref{per:join}, has $\equal$ as its identity element and $\qmark$ as its 
absorbing element. \emph{Meet}, shown in Table~\ref{per:meet}, has $\equal$ as 
its absorbing element and $\qmark$ as its identity element. For both operations 
the undisplayed cases are defined by their symmetrical counterparts.

\begin{table*}[hbtp]\centering
\caption{Partial Equivalences -- $\rjoin$ -- Join Operation}
\label{per:join}
\ra{1.2}
\resizebox{0.99\linewidth}{!}{%
\begin{tabular}{@{}rllll@{}}
\toprule
$\rel'$ & &$\rel''$ & &$\rel' \rjoin \rel''$\\
\midrule
$\qmark$ & $\rjoin$  & $\rel$ & = &$ \qmark$ \\ 

\rowcol $\equal$ & $\rjoin$  & $\rel$ & = & $\rel$ \\

$\rels$ &$\rjoin$ &$\srelv{f}{n}{\rel'}$ &= &$\sreljoin{f}{n}$\\

\rowcol $\relv$ &$\rjoin$ &$\vrelv{C}{n}{\rel'}$ &= &$\vreljoin{C}{n}$\\

$\rela$ &$\rjoin$ &$\arel{\rel'}$ &= &$\arel{\rel \rjoin \rel'}$\\

\rowcol $\rela$ &$\rjoin$ &$\aerelnoleftright{\rel'_{\mathit{def}}}{i}{\rel'_{\mathit{exc}}}$ &= &$\aerelnoleftright{\rel \rjoin\rel'_{\mathit{def}}}{i}{\rel \rjoin\rel'_{\mathit{exc}}}$\\

$\relai$ &$\rjoin$ &$\aerelnoleftright{\rel'_{\mathit{def}}}{j}{\rel'_{\mathit{exc}}}\begin{cases}i = j\\i \neq j\end{cases}\hspace{-1cm}$& =
& $\begin{array}{l}
  \aerelnoleftright{\rel_{\mathit{def}} \rjoin \rel'_{\mathit{def}}}{i}{\rel_{\mathit{exc}} \rjoin \rel'_{\mathit{exc}}} \\
  \arel{\rel_{\mathit{def}} \rjoin \rel'_{\mathit{def}} \rjoin \rel_{\mathit{exc}} \rjoin \rel'_{\mathit{exc}}} \\
  \end{array}$ \\
\bottomrule
\end{tabular}
}
\end{table*}

\begin{table*}[hbtp]\centering
\caption{Partial Equivalences -- $\rmeet$ -- Meet Operation}
\label{per:meet}
\ra{1.2}
\resizebox{0.99\linewidth}{!}{%
\begin{tabular}{@{}rllll@{}}
\toprule
$\rel'$ & &$\rel''$ & &$\rel' \rmeet \rel''$\\
\midrule
$\qmark$ & $\rmeet$  & $\rel$ & = &$ \rel$ \\ 

\rowcol $\equal$ & $\rmeet$  & $\rel$ & = & $\equal$ \\

$\rels$ &$\rmeet$ &$\srelv{f}{n}{\rel'}$ &= &$\srelmeet{f}{n}$\\

\rowcol $\relv$ &$\rmeet$ &$\vrelv{C}{n}{\rel'}$ &= &$\vrelmeet{C}{n}$\\

$\rela$ &$\rmeet$ &$\arel{\rel'}$ &= &$\arel{\rel \rmeet \rel'}$\\

\rowcol $\rela$ &$\rmeet$ &$\aerelnoleftright{\rel'_{\mathit{def}}}{i}{\rel'_{\mathit{exc}}}$ &= &$\aerelnoleftright{\rel \rmeet\rel'_{\mathit{def}}}{i}{\rel \rmeet\rel'_{\mathit{exc}}}$\\

$\relai$ &$\rmeet$ &$\aerelnoleftright{\rel'_{\mathit{def}}}{j}{\rel'_{\mathit{exc}}}\begin{cases}i = j\\i \neq j\end{cases}\hspace{-1cm}$& =
& $\begin{array}{l}
  \aerelnoleftright{\rel_{\mathit{def}} \rmeet \rel'_{\mathit{def}}}{i}{\rel_{\mathit{exc}} \rmeet \rel'_{\mathit{exc}}} \\
  \arel{\rel_{\mathit{def}} \rmeet \rel'_{\mathit{def}} \rmeet \rel_{\mathit{exc}} \rmeet \rel'_{\mathit{exc}}} \\
  \end{array}$ \\
\bottomrule
\end{tabular}
}
\end{table*}

%\subsection{Paths and Correlation Types}\label{ch7:pcortypes}

\subsubsection{Paths}
The partial equivalence relations discussed in Section~\ref{sec:cor:per} and
defined in~\ref{corpertyppe} are enough to represent fine-grained information
for values of the same structured type. For the \disp{stop_thread} example
discussed in Section~\ref{sec:cintro:example} these would suffice to express the
equality of the \disp{pid}, \disp{current_thread} and \disp{address_space}
fields between the input process \disp{in} and the output process \disp{o}, by
simply mapping this pair to the following partial equivalence:
 
\[
\left\{
  \begin{array}{lll}
   \textrm{\disp{threads}}         &\mapsto &\qmark \\ 
   \textrm{\disp{pid}}             &\mapsto &\equal \\ 
   \textrm{\disp{current\_thread}} &\mapsto &\equal\\ 
   \textrm{\disp{address\_space}}  &\mapsto &\equal\\ 
  \end{array}
\right\}.
\] 
However, the partial equivalence relations cannot, for instance, be used to 
convey the equality at line 1 in Figure~\ref{cor:example:body} between the value 
of the \disp{threads} field of \disp{in} and the local \disp{ta} variable. By not
tracking information such as this, we lose the targeted information regarding the 
\disp{threads} field, denoted by $\rel_{th}$ in Figure~\ref{cor:example:results}.   
In order to express this information, we first need to be able to refer to the 
substructure \disp{in.threads} and relate its value to the one of \disp{ta}.

To this end, rather than handling only partial equivalences between pairs of
variables of the same type and approximating the rest to $\qmark$ -- the element
that conveys no information -- we introduce an intermediate level, allowing us
to store relations between subparts of values. We begin by introducing
\emph{access paths}. Unlike the \emph{symbolic paths} introduced in
Chapter~\ref{chapter6} and defined in~\ref{ch6:sympath:def}, that are used for
computing dependency summaries with context-sensitive elements, the paths used
for the correlation analysis are \emph{actual access} paths inside some value's
structure. The symbolic paths used in deferred dependencies may cover multiple
actual paths inside a value, whereas the \emph{access paths} required for the
correlation analysis represent unique chains of internal accesses leading to a
\emph{single}, nested subvalue. Each access path is rooted at one of the
program's variables. It is noteworthy to remark that in both cases, an
intermediate level below variables needs to be introduced as soon as
fine-grained relations between pairs of variables are considered, directly or
indirectly.  In the case of deferred dependencies this was not the main goal per
se but rather a mechanism for obtaining more precision in specific cases for
already pertinent dependency results. In contrast, for the correlation results
this is imperative for obtaining useful, expressive information in non-trivial
cases.  We therefore define a recursive type $\cpath \in \cptype$ encompassing
this.

\begin{definition}{Access Path Type $\cpath \in \cptype$.}\label{ch7:apathtype:definition}
\[
\begin{array}{lll}
 \cpath := &\ver \pempty     & \textrm{empty -- root}  \\ 
           &\ver \pstruct\cpath & f \in \fset \\
           &\ver \pvar\cpath    & C \in \cset \\
           &\ver \pcell\cpath   & \textrm{$i$ index, program variable.} 
\end{array}
\]   
\end{definition}

\noindent The \emph{empty} path, denoted by $\pempty$, is the special case denoting an
access to an entire element, i.e. the root. The action of appending a 
\emph{non-empty} path $\cpath'$ to another path $\cpath$ is denoted by 
$\cpath \append\cpath'$. For instance, the path denoting the 
\disp{current_state} field of the \disp{i}-th active, associated thread of the 
\disp{in} process of our \disp{stop_thread} predicate would be the following: 
\emph{in.threads$\pcell$@Some.t.current\_thread}.
  
Meaningful information is conveyed by associating paths and partial equivalence
relations. For instance, the equality between \disp{in.threads} and \disp{ta} at 
line 1 in Figure~\ref{cor:example:body} can be expressed by associating {\equal} to the
pair of subelements identified by the {\disp{.threads}} path in \disp{in} and by 
$\pempty$ in \disp{ta}. We call \emph{correlation} such a mapping from a pair of 
access paths to a partial relation. After setting the \disp{i}-th element of 
\disp{ta} to \disp{ti}, the thread with the current state set to \disp{Blocked} 
and everything else left unmodified, we could express the relation between 
\disp{in} and \disp{ta} by two correlations, namely:

\[
\begin{array}{lrll}
          &(\textrm{\disp{.threads}}, \pempty) & \mapsto &\aerel{\equal}{\textrm{\disp{i}}}{\qmark}\\ 
          &(\textrm{\disp{.threads}}\langle\textrm{\disp{i}}\rangle@\textrm{\disp{Some.t}}, \langle\textrm{\disp{i}}\rangle@\textrm{\disp{Some.t}} ) &\mapsto & 
          \left\{\begin{array}{rll}
          \textrm{\disp{identifier}} &\mapsto &\equal \\
          \textrm{\disp{current\_state}} &\mapsto &\qmark \\
          \textrm{\disp{stack}} &\mapsto &\equal \\
          \end{array}\right\}. 
\end{array}\\%!%!%! I suppose the double \\ was not intentional.
\] 
%
To this end, we introduce \emph{correlation maps} $\corv \in \cor$, defined 
below. 
\begin{definition}{Correlation Maps $\corv \in \cor$.}\label{ch7:cormaps:definition}

Correlation maps $\corv \in \cor$ are finite mappings 
from pairs of paths to partial equivalence relations $\rel \in \rdom$:
\[\cor : \cptype \times \cptype \; \to \rdom.\]
\end{definition}

Generally, for two given variables \emph{e} and \emph{o}, a correlation 
$(\cpath, \crho) \mapsto \rel $ specifies that \emph{e} and \emph{o} have nested 
subelements, respectively identified by the inner paths $\cpath$ and $\crho$, 
whose values are related by the relation $\rel$. 

\subsubsection{Alignment}
\def\pproj{\rightsquigarrow}
\def\pinj{\curvearrowleft}
\def\ajoin{\hat{\bigvee}}

\subsection{Correlation analysis}

As was the case for the dependency analysis presented in Chapter~\ref{chapter5},
we are working with a control flow graph (CFG) representation of the predicates'
bodies. We remind that nodes represent program states and edges are defined by
statements with a particular exit label $\lambda$. In our case, all the outgoing 
edges of a node $n$ bear the different cases of the same statement $s$ found at 
the program point $n$. For each statement $s$ there is an edge labeled 
$s, \lambda_k$ for each of its possible exit labels $\lambda_k$ (as discussed in
Section~\ref{sec:lang:mysmil:cfg}). However, 
similarly to the dependency analysis, our correlation analysis does not depend on 
this specificity.  

Intraprocedurally, correlation information has to be kept at each point of the 
control flow graph, for each input and output pair of the node. 
\begin{definition}{Intraprocedural Correlation Summaries.}\label{ch7:intracordom:definition}

An \emph{intraprocedural} correlation summary is a mapping from pairs of variables 
$v \in \mathcal{V}$ to correlation maps:
\def\nocor{\boxempty}
 \[
  \intracor \in \mathcal{K},  \;\; \intracor : \mathcal{V} \times \mathcal{V} \rightarrow \cor.\]
\end{definition}\label{ch7corintrasum} 
% 
%% is thus a mapping from pairs of variables $v \in \mathcal{V}$ to 
%% correlation maps. 
\noindent There is one special case, called \emph{NoCorrelation}, which 
associates $\qmark$ -- the least precise partial 
relation -- to any pair of variables, on any pair of valid, compatible paths.
It is the top element at the intraprocedural level. 
\emph{Unreachable} is used for nodes that cannot be reached, as its name implies, 
and constitutes the bottom element at the intraprocedural level.   

For each node of a given control flow graph, $\intracor(e, o)$ retrieves the 
correlation map between the local variable $e$ and the output 
variable $o$. If a mapping for $e$ and $o$ does not currently exist, 
$\intracor(e, o)$ retrieves the correlation $(\pempty,\pempty) \mapsto \equal$ 
when $e = o$ or the empty correlation map $\emptyset$, otherwise. 

Establishing the partial order $\ileq$ and the join operation $\ijoin$ is
straightforward: $\aleq$ (Definition~\ref{ch7:cormapporder:definition}) and
$\ajoin$ (Definition~\ref{ch7:cormapjoin:definition}) are extended pointwise to
an intraprocedural summary, for each ordered input-output pair and its
associated correlation map.

\begin{definition}{Partial Order for Intraprocedural Correlation Summaries.}\label{ch7:intraporder:definition}
\[
\ileq \,\subseteq \mathcal{K} \times \mathcal{K} \qquad%\;\;\;\;\;\;\;\;
\intracor_1 \ileq \intracor_2 \iff \forall e, o \in \mathcal{V}, \; \intracor_1(e, o) \aleq \intracor_2(e, o).
\]
\end{definition}

\begin{definition}{Join Operation for Intraprocedural Correlation Summaries.}\label{ch7:intrajoinop:definition}
\[
%\bigvee : \mathscr{D} \times \mathscr{D} \to \mathscr{D} \;
\ijoin: \mathcal{K} \times \mathcal{K} \to \mathcal{K} \qquad
%
\intracor_1 \ijoin \intracor_2 = \intracor_3 \iff 
\forall (e, o),\; \intracor_3(e, o) = \intracor_1(e, o)\; \ajoin\; \intracor_2(e, o).
\]
\end{definition}
%% \phantom{a}
%
%% \noindent is straightforward: $\aleq$ and $\ajoin$ are extended pointwise to an 
%% intraprocedural summary, for each ordered input-output pair and its associated 
%% correlation map.
%
%

Our correlation analysis is a \emph{backward} data-flow analysis, computing an 
intraprocedural summary at each point of the control flow graph. This represents 
the correlations at the node's \emph{entry point}. For each exit label, it 
traverses the control flow graph starting with its corresponding exit node. The 
intraprocedural summary for the currently analysed label is initialized with 
pairs between the local value of each associated output variable of the label and 
the final value of the same output variable, mapped to 
$(\pempty, \pempty) \mapsto \equal$. The analysis traverses the control flow 
graph and gradually refines the correlations, using Kildall's worklist 
algorithm~\cite{kildall73}, until a fixed point is reached. 
Table~\ref{ch7:representation} summarizes the representation and general equation of 
the statements. For each statement, the presented data-flow equation operates 
on the intraprocedural summaries of the statement's \emph{successor} nodes. The 
intraprocedural summary at the \emph{entry point} of the node is obtained by 
\emph{joining} the contributions of each \emph{outgoing} edge. 

\begin{definition}\label{ch7:edgecontrib:definition}
The contribution 
of an edge $(n, n_i)$ labeled with $s$ and $\lambda_i$ is given by
$\Ctransfer {\intracor_{n_i}}{s}{\lambda_i} \in \mathbb{C}$ where 
$\Ctransfer{.}{s}{\lambda_i}$ is the \emph{transfer function} of the edge labeled 
$s, \lambda_i$. 
\end{definition}
\noindent We note that there are four statements supported by {\asmil}, 
i.e. the equality test, no-operation, the partial structure equality test and the
possible variant test, that have no write effects and thus have no own 
contribution and are not included in Table~\ref{ch7:representation}. Excepting the 
no-operation statement, the correlation information at their entry point is obtained 
by simply joining the intraprocedural summaries of their successor nodes on the 
{\lbtrue} and {\lbfalse} exit labels. For the no-operation statement, the correlation 
information at the entry point is identical to the intraprocedural summary of its 
only successor node, the one on the {\lbtrue} exit label.  
 
\begin{table*}[hbtp]\centering
\caption{Statements -- Representations and Data-Flow Equations}
\label{ch7:representation}
\begin{minipage}{\textwidth}%
\makeatletter
\@tempdima=\textwidth%
\advance\@tempdima by -6cm\relax%
\advance\@tempdima by -\tabcolsep\relax%
\edef\secondcolumnwidthchsevenrepresentation{\the\@tempdima}%
\makeatother%
\begin{tabular}{@{}m{6cm}c@{}}
\toprule
\textrm{\textsf{Representation}} & \textrm{\textsf{Equation}} \\
\midrule
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto, node distance=0.9cm,
                     semithick,
                     statt/.style={fill=lightgray,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.6cm,minimum height=.45cm}]

   \node[statt]         (N)  {$n$};
   \matrix[below=of N,row sep=0cm,column sep=.2cm]{
     \node[statt]         (N1) {$n_1$}; &
     \node{\vphantom{$n_i$}$\ldots$}; &
     \node[statt]         (Ni) {$n_i$}; &
     \node{\vphantom{$n_i$}$\ldots$}; &
     \node[statt]         (Nn) {$n_n$}; \\
   };
   \node[anchor=east, inner sep=0pt] (iN) at (N.west) {$\intracor_{n}$};
   \node[anchor=east, inner sep=0pt] (iN1) at (N1.west) {$\intracor_{n_1}$};
   \node[anchor=south east, inner sep=0pt] (iNi) at (Ni.north west) {$\intracor_{n_i}$};
   \node[anchor=west, inner sep=0pt] (iNn) at (Nn.east) {$\intracor_{n_n}$};

   \draw (N) --             node[left] (lN1) {$s, \lambda_1$} (N1);
   \draw (N) --             node[right] (lNn) {$s, \lambda_n$} (Nn);
   \draw (N) --             node[anchor=center,fill=white,inner sep=2pt] (lNi) {$s, \lambda_i$} (Ni);

   \node[rectangle,draw=none,very thin,fit=(N) (N1) (Ni) (Nn) (lN1) (lNn) (lNi) (iN1) (iNi) (iNn),inner sep=0pt] (fitbox) {};

   \path[use as bounding box] (fitbox.north east) rectangle (fitbox.south west);
 \end{tikzpicture}
&\multicolumn{1}{@{}m{\secondcolumnwidthchsevenrepresentation}@{}} 
{ \centering \Large{$ \displaystyle 
\intracor_n = \largeijoin_{\hspace{1em}\mathclap{\text{\rule{0pt}{3.8ex}}n \xrightarrow {s, \lambda_i} n_i}\hspace{1em}} \Ctransfer {\intracor_{n_i}}{s}{\lambda_i} $}} \\ 
\end{tabular}
\end{minipage}
\begin{minipage}{\textwidth}%
 \centering%
 \scriptsize%
 \begin{tabular}{*{5}{l}}
    \toprule
    \textsf{Statement} & &$\mathllap{\Ctransfer{.}{s}{\lambda}:\quad}\dls$ & \kset \\ 
    \midrule

    \textsf{Assignment} &$o:=e$  &$\{ (e, o) \mapsto [(\pempty, \pempty) \mapsto \equal] \}$   
    & $\{o\}_{\mathit{true}}$  \\\\

    \textsf{New Struct}&$\recordnew$ &$\forall i, 1\leq i \leq n \; \{(e_i, r) \mapsto [(\pempty, .f_i) \mapsto \equal]\}$ &$\{r\}_{\mathit{true}}$ \\\\

    \textsf{Destructure} &$\recordall$ &$\forall i, 1\leq i \; \leq n \; \{(r, o_i) \mapsto [(.f_i, \pempty) \mapsto \equal]\}$ &$\{o_i\}_{\mathit{true}}$ \\\\

    \textsf{Get Field} & $\recordget$ & $\{ (r, o) \mapsto [(.f_i, \pempty) \mapsto \equal] \}$ &$\{o\}_{\mathit{true}}$ \\\\

    \textsf{Set Field} &$\recordset$  & 
      $\{ (r, r') \mapsto [(\pempty, \pempty) \mapsto $ & $\{r'\}_{\mathit{true}}$ \\
      & & $\,\,\;\;\srelibot]$ &\\
      & & $\;\;(e, r') \mapsto [(\pempty, .f_i) \mapsto \equal]\}$ & \\\\
   
    \textsf{Create Var.} & $\varcons$ &  
      $\{(e, v) \mapsto [(\pempty, @C_p.e) \mapsto \equal]\}$ 
      & $\{v\}_{\mathit{true}}$ \\\\

    \textsf{Var. Switch} & $\varswitch$ & 
      $\{(v, o_i) \mapsto [(@C_i.e, \pempty) \mapsto \equal]\} $
      & $\{o_i\}_{\lambda_{C_i}}$ \\\\
  
    \textsf{Array Get} & $\arrayget$  & $\{(a, o) \mapsto [(\pcell, \pempty) \mapsto \equal] \}$ &$\{o\}_{\mathit{true}}$ \\\\
   
    \textsf{Array Set} & $\arrayset$ &  
      $\{ (a, a') \mapsto [(\pempty, \pempty) \mapsto \relaitop]$
      & $\{a'\}_{\mathit{true}}$ \\
      &&$\;\; (e, a') \mapsto [(\pempty, \pcell) \mapsto \equal ]\}$&\\ 

    \bottomrule
  \end{tabular}
\end{minipage}

\end{table*}

The transfer function $\Ctransfer{.}{s}{\lambda}$ formalizes the correlations 
created by the statement $s$ on the label $\lambda$ between its local input 
variables and its local output variables, denoted by $\dls$, as well as the 
set {\kset} of variables whose values have been redefined by the statement 
$s$ on the label $\lambda$. These are shown in Table~\ref{ch7:representation}. 
There is one crucial difference between transfer functions 
$\Ctransfer{.}{s}{\lambda}$ and intraprocedural summaries $\intracor$. An 
intraprocedural summary $\intracor$ implicitly maps any pair $(v,v)$ for 
$v \in {\mathcal{V}}$ to $(\pempty, \pempty) \mapsto \equal$. On the contrary, 
in $\dls$, when the variable $v$ is used as both input and output by the 
statement $s$, the pair $(v, v)$ is mapped to the correlation map known between the 
input's $v$ old value and the output's $v$ fresh value. Otherwise, when $v$ is 
an output, i.e. $v \in \mathit{kill}_{\lambda}$, but not an input of $s$, $(v, v)$ 
is mapped to $\emptyset$. We remark that $\intracor$ represents a \emph{state},
while $\dls$ represents a transition.

\def\dli{c_{\lambda_i}^s}
In order to obtain the contribution $\Ctransfer {\intracor_{n_i}}{s}{\lambda_i}$ of 
an edge labeled with $s$ and $\lambda_i$, we need to connect the information
given by $\dli$ to the information contained in the intraprocedural summary 
$\intracor_{n_i}$. For example, at the entry of node 3 in Figure~\ref{example:body},
when considering the scenario in which the predicate exits with {\disp{true}},
the intraprocedural summary contains the mapping: \\
%
\begin{center}%
  \scalebox{0.88}{%
    \parbox{\linewidth}{%
      \[
      \begin{array}{lrl}
        (\textrm{\disp{th}}, \textrm{\disp{o}}) &\mapsto  
        &\left[(@\textrm{\disp{Some.t}}, \textrm{\disp{.threads}}
          \langle\textrm{\disp{i}}\rangle@\textrm{\disp{Some.t}}) \mapsto          
          \left\{\begin{array}{rll}
                   \textrm{\disp{identifier}} &\mapsto &\equal \\
                   \textrm{\disp{current\_state}} &\mapsto &\qmark \\
                   \textrm{\disp{stack}} &\mapsto &\equal \\
                 \end{array}\right\}\right].
      \end{array}
      \]%
    }%
  }%
\end{center}

\noindent On the {\disp{true}} edge, statement 2 creates the mapping:
%
\[
\begin{array}{lrl}
(\textrm{\disp{ta}}, \textrm{\disp{th}}) &\mapsto  
&\left[(\langle\textrm{\disp{i}}\rangle, \pempty) \mapsto \equal\right].
\end{array}
\] 

\noindent Intuitively, since we are traversing the graph backwards and we are mapping 
\emph{ordered} (local) input-output pairs, (\disp{ta}, \disp{th}) and (\disp{th}, 
\disp{o}) can be seen as a \emph{def-use} pair: the correlation associated to 
(\disp{ta}, \disp{th}) expresses the relation between the \emph{defined} value of 
{\disp{th}} and the input {\disp{ta}} used for creating it, while the
correlation associated to (\disp{th},~\disp{o}) shows a subsequent \emph{use}
of that value of {\disp{th}} for creating {\disp{o}}. The contribution of 
statement 2 on the {\disp{true}} edge should capture this flow of \disp{ta}'s 
value to \disp{o}'s value, through the variable \disp{th}. Thus, it should 
contain a mapping for the pair (\disp{ta}, \disp{o}). In the general case we 
need to detect any variable $r$ such that $[(p, r) \mapsto \corv] \in \dli$,   
$[(r, q) \mapsto \corv'] \in \intracor_{n_i}$ and compute the mapping for $(p,q)$
in $\Ctransfer{\intracor_{n_i}}{s}{\lambda_i}$.

In order to compute the correlation map associated to (\disp{ta}, \disp{o}),
we take into account the fact that both the right path $\pempty$ of 
$\dls(\textrm{\disp{ta}}, \textrm{\disp{th}})$ and the left path $@$\disp{Some.t} 
of $\intracor_{n_3}\textrm{(\disp{th}, \disp{o}})$ refer to the {\disp{th}} variable.
However, they do not represent traversals of the same depth: $\pempty$ refers to 
the entire value of {\disp{th}}, while $@$\disp{Some.t} refers to the value below 
the constructor \disp{Some}. Between {\disp{ta}} and {\disp{o}} we can conclude 
that the values nested under the \disp{Some} constructor of the {\disp{i}}-th 
elements are related:
\[
\begin{array}{lrl}
(\textrm{\disp{ta}}, \textrm{\disp{o}}) &\mapsto  
           &\left[\langle\textrm{\disp{i}}\rangle@\textrm{\disp{Some.t}}, 
           \textrm{\disp{.threads}}\langle\textrm{\disp{i}}\rangle@\textrm{\disp{Some.t}}) \mapsto          
           \left\{\begin{array}{rll}
           \textrm{\disp{identifier}} &\mapsto &\equal \\
           \textrm{\disp{current\_state}} &\mapsto &\qmark \\
           \textrm{\disp{stack}} &\mapsto &\equal \\ 
           \end{array}\right\}\right].
\end{array}
\] 
 
We call the process of obtaining the correlation map associated to (\disp{ta}, 
\disp{o}) from the correlations associated to (\disp{ta}, \disp{th}) and 
(\disp{th}, \disp{o}) \emph{composition}.

In the general case, the composition operation is denoted by $\compose$ and it 
refers to the process of computing the flow of a variable $p$ to a variable $q$ 
through an intermediate variable $r$. Thus, when knowing that 
$(p, r) \mapsto [(\cpath, \crho) \mapsto \rel]$ and that 
$(r, q) \mapsto [(\cpath', \crho') \mapsto \rel']$,
we must first obtain the \emph{link} (Definition~\ref{ch7:link:definition})
between the paths $\crho$ and $\cpath'$ relating subvalues of $r$ to subvalues of
$p$ and $q$, respectively. This is obtained by \emph{matching} with $\findl$ 
(Definition~\ref{ch7:match:definition}).   
In the context of the example given above, $\crho$ and $\cpath'$ are the paths 
referring to subvalues of the {\disp{th}} variable, i.e. $\pempty$ and 
$@$\disp{Some.t}, respectively. If the two paths are incompatible, i.e. they
refer to different, unrelated subvalues of $r$, there is no flow between $p$ 
and $q$ through $r$. If the paths are compatible, we can compute the correlation
between $p$ and $r$, by distinguishing between the three different possible link 
cases obtained with $\findl$. 

The case when the same subvalue of $r$ identified by $\crho$ 
(and the identical $\cpath'$) is related to both $p$ and $q$ is depicted 
below:

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \identical$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture}
%
&  \hspace{-4cm}%%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=2.5cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, zag=8mm, 
 %%            [,name=ax1, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d1, 
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho$, zag=8mm, 
 %%            [,name=ax2, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d2,
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Third
 %%    [, dot tree,name=ba3, triangle fit whole subtree={bottom space=.5cm,},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho'$, zag=6mm, 
 %%            [,name=ax3, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d3, 
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=4pt, thick, orange] (ax1) edge[bend left] node[above]{$\rel$} (ax2);
 %%   \draw[<->, shorten=4pt, thick, orange] (ax2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%  % \draw[<->, shorten=2pt, dashed, thick, iburg,] (ax1) edge[bend right] node[below]{$\mathcal{R} \rjoin \mathcal{R}'$} (ax3);
 %%  \path (v1)  node[xshift=-2.8cm, yshift=2cm]{\Large$p$};
 %%  \path (v2) node[xshift=-2.7cm, yshift=2cm]{\Large$r$};
 %%    \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%    \path (0,0) node[xshift=3.5cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest}
\end{longtable}

\noindent In this case, computing the flow from $p$ to $q$ through $r$ is rather 
straightforward. Since the same subvalue of $r$ is related to $p$'s 
subvalue identified by $\cpath$ and to $q$'s subvalue identified by $\crho'$,
we can relate these two subvalues and map the pair $(\cpath, \crho')$ to the 
relation obtained by composing $\rel$ and $\rel'$. We note that given the special 
form of partial relations $\rel \in \rdom$, the compose operation at this level is 
equivalent to $\rjoin$\footnote{However, this would not be the case anymore for 
a more complex partial relation type, including not only equivalences but 
also more general relations.} (Definition~\ref{ch7:joinoperationper:definition}). 
The computation of the correlation for $p$ and $q$ is 
depicted below:

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \identical$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture}%\hspace{-4cm}
&\hspace{-4cm} %%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=2.5cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, zag=8mm, 
 %%            [,name=ax1, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d1, 
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho$, zag=8mm, 
 %%            [,name=ax2, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d2,
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Third
 %%    [, dot tree,name=ba3, triangle fit whole subtree={bottom space=.5cm,},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho'$, zag=6mm, 
 %%            [,name=ax3, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               [,name=d3, 
 %%               ]
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=4pt, thick, orange] (ax1) edge[bend left] node[above]{$\rel$} (ax2);
 %%   \draw[<->, shorten=4pt, thick, orange] (ax2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%  \draw[<->, shorten=2pt, dashed, thick, iburg,] (ax1) edge[bend right,looseness=1.15] node[below]{$\rel \rjoin \rel'$} (ax3);
 %%  \path (v1)  node[xshift=-2.8cm, yshift=2cm]{\Large$p$};
 %%  \path (v2) node[xshift=-2.7cm, yshift=2cm]{\Large$r$};
 %%    \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%    \path (0,0) node[xshift=3.5cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest}
\end{longtable}
   
The subelements of $r$ related to $p$ and to $q$ respectively can also
have different granularities, one being nested deeper in $r$ than the other. 
For instance, the subvalue of $r$ identified by the path $\crho$ can be 
closer to the root than its subelement identified by $\cpath'$ related to 
$q$. This case is depicted below:

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \leftcase\;\csigma$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture}
&\hspace{-4cm} %%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=3cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, zag=5mm, 
 %%            [,name=ax1, zig=6mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%               [; $\csigma$, name=d1, edge label node style+={fill=iburg, text=iburg},
 %%                            invisible tree, %only=<7->{triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},},
 %%               []
 %%               []
 %%             ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho$, zag=8mm, 
 %%            [,name=ax2, zig=8mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%               [; $\csigma$, name=d2, edge label swap, edge label node style+={fill=caribbeangreen, text=caribbeangreen},
 %%                            % only not=<6->{invisible tree}, only=<6->{
 %%                              triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, caribbeangreen},%},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Third
 %%    [, dot tree,name=ba3, triangle fit whole subtree={bottom space=.5cm,},% start squiggly tree,
 %%        [, 
 %%          [;$\crho'$, 
 %%            [,name=ax3, triangle fit whole subtree={triangle sep=1mm, bottom space=0.1cm, caribbeangreen},
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=2pt, thick, orange] (ax1) edge[bend left,out=40,in=140,looseness=0.9] node[above]{$\rel$} (ax2);
 %%   \draw[<->, shorten=2pt, thick, caribbeangreen] (d2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%   %\draw[<->, shorten=2pt, dashed, thick, iburg, only not=<8->{opacity=0}] (d1) edge[out=-35,in=-135,looseness=1] node[below]{$ \pproj(\sigma, \mathcal{R}) \rjoin \mathcal{R}'$} (ax3);
 %%  \path (v1)  node[xshift=-3.2cm, yshift=1.9cm]{\Large$p$};
 %%  \path (v2) node[xshift=-2.7cm, yshift=1.9cm]{\Large$r$};
 %%  \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%  \path (0,0) node[xshift=3.9cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest}
\end{longtable}

\noindent In this case we can only detect the flow of $p$ to $q$ at the level of $r$'s
subelement that is related to both $p$ and $q$, i.e. the subelement nested deeper.
Thus, in order to compute the correlation between $p$ and $q$, we need to project 
$\csigma$ on $\rel$, and to compose the obtained relation with $\rel'$. This is 
summarized by the following figure:  

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \leftcase\;\csigma$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture}
& \hspace{-4cm} %%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=3cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, zag=5mm, 
 %%            [,name=ax1, zig=6mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%               [; $\csigma$, name=d1, edge label node style+={fill=iburg, text=iburg},
 %%                             triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%               []
 %%               []
 %%             ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho$, zag=8mm, 
 %%            [,name=ax2, zig=8mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%               [; $\csigma$, name=d2, edge label swap, edge label node style+={fill=caribbeangreen, text=caribbeangreen},
 %%                             triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, caribbeangreen},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %% %Third
 %%    [, dot tree,name=ba3, triangle fit whole subtree={bottom space=.5cm,},% start squiggly tree,
 %%        [, 
 %%          [;$\crho'$, 
 %%            [,name=ax3, triangle fit whole subtree={triangle sep=1mm, bottom space=0.1cm, caribbeangreen},
 %%               []
 %%               []
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=2pt, thick, orange] (ax1) edge[bend left,out=40,in=140,looseness=0.9] node[above]{$\rel$} (ax2);
 %%   \draw[<->, shorten=2pt, thick, caribbeangreen] (d2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%   \draw[<->, shorten=2pt, dashed, thick, iburg,] (d1) edge[out=-35,in=-135,looseness=1] node[below]{$ \pproj(\csigma, \rel) \rjoin \rel'$} (ax3);
 %%  \path (v1)  node[xshift=-3.2cm, yshift=1.9cm]{\Large$p$};
 %%  \path (v2) node[xshift=-2.7cm, yshift=1.9cm]{\Large$r$};
 %%  \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%  \path (0,0) node[xshift=3.9cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest}
\end{longtable}

Finally, in the complementary case, the subvalue of $r$ identified by the 
path $\crho$ and correlated to $p$ can be nested deeper than the subvalue 
identified by $\cpath'$ which is correlated to $q$. This case is depicted 
below:

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \rightcase\;\csigma$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture}
&\hspace{-3.2cm} %%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=2cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, name=d1, zag=5mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%              for children={invisible},
 %%               []
 %%               []
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho$, zag=8mm, 
 %%            [,name=ax2, zig=8mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, caribbeangreen},%!%!%!%! Stray beamer only=..., should it be caribbeangreen or not?
 %%               [; $\csigma$, name=d2, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%                 %only=<11>{edge label node style+={fill=iburg, text=iburg},},
 %%                 for children={invisible},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%     [, dot tree,name=ba3,
 %%        %only=<9>{invisible tree},
 %%        triangle fit whole subtree={bottom space=.5cm,},
 %%        for tree={before drawing tree={x+=1.5cm},},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho'$, zag, 
 %%            [,name=ax3, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, caribbeangreen},
 %%               [; $\csigma$,name=d3, %only=<11->{triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, iburg},},
 %%                invisible,
 %%                 %only=<11>{edge label node style+={fill=iburg, text=iburg},},
 %%                 for children={invisible},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=2pt, thick, orange] (d1) edge[bend left] node[above]{$\rel$} (d2);
 %%   \draw[<->, shorten=2pt, thick, caribbeangreen] (ax2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%   %\draw[<->, shorten=2pt, dashed, thick, iburg, only=<-10>{opacity=0}] (d1) edge[out=-60, in=-150] node[below]{$\mathcal{R} \rjoin \pproj(\mathcal{R}', \sigma)$} (d3);
 %%   \path (v1)  node[xshift=-1.7cm, yshift=2cm]{\Large$p$};
 %%   \path (v2) node[xshift=-2.7cm, yshift=2cm]{\Large$r$};
 %%   \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%   \path (0,0) node[xshift=3.9cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest} 
\end{longtable}

\noindent As in the previous case, we can only detect the flow of $p$ to $q$ at 
the level of $r$'s subelement that is related to both $p$ and $q$, i.e. the 
subelement nested deeper. In this case we need to project $\csigma$ on $\rel'$ 
and to compose the obtained relation with $\rel$. The flow between $p$ and $q$ is 
at the level of the subvalues identified by $\cpath$ and $\crho'::\csigma$ respectively.
This is illustrated below: 

\begin{longtable}{l@{}l@{}}
\begin{tikzpicture}
\node[scale=0.8] (a){$\findl(\crho, \cpath') = \rightcase\;\csigma$};
\node[below of=a] (b){\phantom{A}};
\end{tikzpicture} \hspace{-3.2cm}
&  
%%\begin{forest}
 %%    oni tree defaults,
 %%    [, % Start directly with a comma: no node contents
 %%     phantom,% phantom == invisible node, just here for the layout. It is the fake "common ancestor" to both trees shown in this diagram
 %%     s sep=2cm,% Trees have two axes for layout s (sibling), the "horizontal" axis, and l (level), the "vertical" axis. Make the two trees separated by a centimeter
 %%     %
 %%     % Do not leave blank lines, always put a % when you want to skip a line, otherwise it crashes forest
 %%    %First
 %%    [, dot tree,name=ba1, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath$, name=d1, zag=5mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, orange},
 %%              for children={invisible},
 %%               []
 %%               []
 %%          ]
 %%        ]
 %%      ]
 %% %Second
 %%     [, dot tree,name=ba2, triangle fit whole subtree={bottom space=.5cm},% start squiggly tree,
 %%        [, zig
 %%          [;$\cpath'$, zag=8mm, 
 %%            [,name=ax2, zig=8mm, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, caribbeangreen},
 %%               [; $\csigma$, name=d2, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, orange},
 %%                 edge label node style+={fill=iburg, text=iburg},
 %%                 for children={invisible},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%     [, dot tree,name=ba3,
 %%        %only=<9>{invisible tree},
 %%        triangle fit whole subtree={bottom space=.5cm,},
 %%        for tree={before drawing tree={x+=1.5cm},},% start squiggly tree,
 %%        [, zig
 %%          [;$\crho'$, zag, 
 %%            [,name=ax3, zig, triangle fit whole subtree={triangle sep=1mm, bottom space=0.3cm, caribbeangreen},
 %%               [; $\csigma$,name=d3, triangle fit whole subtree={triangle sep=1mm, bottom space=0.2cm, iburg},
 %%                 edge label node style+={fill=iburg, text=iburg},
 %%                 for children={invisible},
 %%                []
 %%                []
 %%               ]
 %%            ]
 %%          ]
 %%        ]
 %%      ]
 %%    ]
 %%   \draw[<->, shorten=2pt, thick, orange] (d1) edge[bend left] node[above]{$\rel$} (d2);
 %%   \draw[<->, shorten=2pt, thick, caribbeangreen] (ax2) edge[bend left] node[above]{$\rel'$} (ax3);
 %%   \draw[<->, shorten=2pt, dashed, thick, iburg,] (d1) edge[out=-60, in=-150] node[below]{$\rel \rjoin \pproj(\csigma,\rel')$} (d3);
 %%   \path (v1)  node[xshift=-1.7cm, yshift=2cm]{\Large$p$};
 %%   \path (v2) node[xshift=-2.7cm, yshift=2cm]{\Large$r$};
 %%   \path (0,0) node[xshift=0.5cm, yshift =-0.4cm]{\Large$\cpath'$};
 %%   \path (0,0) node[xshift=3.9cm, yshift =-0.2cm]{\Large$q$};
 %%  \end{forest} 
\end{longtable}


Formally, if the $\crho$ and $\cpath'$ paths are compatible, we 
compose the correlation elements $(\pi, \rho) \mapsto \rel$ and 
$(\pi', \rho') \mapsto \rel'$, thereby obtaining a new correlation 
element, $(\pi_{\bullet}, \rho_{\bullet}) \mapsto \rel_{\bowtie}$, which is  
computed as shown below.

\begin{definition}{Computing $(\pi_{\bullet}, \rho_{\bullet}) \mapsto \rel_{\bowtie}$.}\label{ch7:compcomposeelem:definition}
\[
\begin{array}{l}
%% (\pi_{\bullet}, \rho_{\bullet}) = (\pi, \rho) \bullet (\pi', \rho') \;\;
 (\pi_{\bullet}, \rho_{\bullet}) =(\pi, \rho) \bullet (\pi', \rho') \overset{\mathit{def}}{=}
\left\{\begin{array}{ll}
         (\pi, \rho')            &{\textrm{when} \findl(\rho, \pi') = \identical}  \\
         (\pi :: \sigma, \rho')  &{\textrm{when} \findl(\rho, \pi') = \leftcase\; \sigma} \\         
         (\pi, \rho'::\sigma)    &{\textrm{when} \findl(\rho, \pi') = \rightcase\; \sigma}\\
\end{array}\right.\\\\
%
 \rel_{\bowtie} = {\rel} \bowtie \rel' \overset{\mathit{def}}{=}
\left\{\begin{array}{ll}
          \rel \rjoin \rel'&{\textrm{when} \findl(\rho, \pi') = \identical}  \\
          \pproj(\sigma, \rel) \rjoin \rel'  &{\textrm{when} \findl(\rho, \pi') = \leftcase\; \sigma} \\         
          \rel \rjoin \pproj(\sigma, \rel') &{\textrm{when} \findl(\rho, \pi') =  \rightcase\; \sigma}\\
\end{array}\right.
%
\end{array}
\]
\end{definition}
%
%
\noindent We note that the use of the projection operation $\pproj$ 
(Definition~\ref{ch7:pprojoperator:definition}) for both compatible,
non-identical link cases for $r$'s access paths related to $p$ and to $q$
respectively, is a consequence of not choosing a canonical form for correlations.
The flexibility confered by the absence of a canonical correlation form is 
visible at the composition level.
   
The composition of correlation maps is denoted by $\acompose$ and defined below. 
\begin{definition}{Composition of Correlation Maps.}\label{ch7:composecormaps:definition}

Computing $\corv_1 \acompose \corv_2$ amounts to intersecting the composition of
all correlation elements from $\corv_1$ and $\corv_2$:\\

\centerline{$
(\corv_1 \acompose \corv_2)(\pi_{\bullet}, \rho_{\bullet}) =
\displaystyle\mathop{\bigwedge\raisebox{-3pt}
{$\displaystyle\mathlarger{\mathlarger{{}_{\mathscr{R}}}}$}}_{\hspace{1.9em}\mathclap{\substack{(\pi, \rho) \mapsto \rel \in \corv_1\\ (\pi', \rho') \mapsto \rel' \in \corv_2 \\ (\pi_{\bullet}, \rho_{\bullet}) =  (\pi, \rho) \bullet (\pi', \rho')}}\hspace{1.9em}}^{} \rel  \bowtie \rel'.
 $}
\end{definition}

Finally, the contribution $\Ctransfer {\intracor_{n_i}}{s}{\lambda_i}$ is 
obtained as defined below. 

\begin{definition}{Contribution $\Ctransfer {\intracor_{n_i}}{s}{\lambda_i}$.}\label{ch7:computecontrib:definition}
\[ \compose : \mathbb{C} \times \mathcal{K} \to \mathcal{K}\;\;\;
 \dls \compose \intracor = \intracor' \;\;\;
 \textrm{where } 
 \displaystyle \intracor'(p,q) = \hat{\bigwedge_{r}} (\dls(p, r) \acompose \intracor(r, q)).\]
\end{definition}
\noindent It is depicted in Figure~\ref{intra:cor:contrib}.

\begin{figure}[hbt]\centering
\begin{tikzpicture}
[scale=0.4, auto]
\node[vertex] (n1) at (10.5,14) {\emph{\phantom{switch }\Large{statement s}\phantom{switch}}}; 
\draw[edge] (10.5,16.3) -- (10.5,15.2); 
%\node [above](l1) at (3.2, 16.15) {a};
\node [above](l9) at (10.45, 16.1) {$(c^s_{\lambda_1} \compose \Delta_{\lambda_1})\ijoin \ldots \ijoin (c^s_{\lambda_n} \compose \Delta_{\lambda_n})$ };
%\node (contrib) at (20.2, 14.8) {c} ;
%\node (line2) at (21, 14.3) {d};

\draw[edge] (8.5, 12.75) -- (7.5, 9.5);
\node [below](l2) at (7.1, 11.9) {$c^s_{\lambda_1}$};
\node [above](l3) at (6.5, 9.4) {$\intracor_{\lambda_1}$};
\draw[edge] (12.5, 12.75) -- (13.5, 9.5);
\node [below](l6) at (10.5, 12.5) {$\ldots$};
\node [below](l4) at (14, 11.8) {$c^s_{\lambda_n}$};
\node [above](l5) at (14.6, 9) {$\intracor_{\lambda_n}$};
\node [below](l7) at (6.2, 12.9) {$c^s_{\lambda_1} \compose \intracor_{\lambda_1}$};
\node [below](l8) at (15, 12.9) {$c^s_{\lambda_n} \compose \intracor_{\lambda_n}$};
\end{tikzpicture}
\caption{Entry Point -- Correlation Information}
\label{intra:cor:contrib}
\end{figure}

\def\opset{\mathcal{O}}

We conclude this section by specifying what it means for intraprocedural
correlation summaries to be \emph{well-formed}, showing the corresponding
inference rule in Table~\ref{ch7:wfintra}. Only ordered input-output pairs
can appear as keys in intraprocedural mappings. Therefore, the well-formedness 
judgement is parameterized by the set of input variables $\inpset$, 
%which are the variables having the right to appear as left members of variable pairs, 
and by the set of output variables $\opset$.
%which are the variables having the right to 
%appear as the right members of variable pairs. 
The former indicate variables that have the right to appear as left members of the
variable pairs, while the latter indicate variables that have the right to appear as 
right members of the variable pairs. 
The correlation map associated to each such input-output pair must be well-typed 
with respect to the types of the variables as given by the typing environment $\Gamma$ 
(Definition~\ref{ch4:typenv:def}). 
The typing judgement for correlation maps was shown in Table~\ref{ch7:wtcormaps}.    

\begin{longtable}{@{}c@{}}
\caption{Well-Formed Intraprocedural Correlation Summaries \newline}
\label{ch7:wfintra}
\endlastfoot
\toprule
%
$\inferrule*[right= WFIntraCor]
{ \forall (e, o) \mapsto \corv \in \intracor \; \\ \Gamma(e) = \tau_e \\
\Gamma(o) = \tau_o \\ e \in \inpset \\ o \in \opset \\\\ 
\Gamma, \inpset \vdash \corv \; : (\tau_e, \tau_o)
}
{\Gamma, \inpset, \opset  \vDash \intracor}
$
\\
\bottomrule
\end{longtable}


\subsection{Intraprocedural Correlation Analysis Illustrated}\label{sec:cor:example}

To better illustrate our correlation analysis at an intraprocedural level and to 
summarize everything that has been presented so far in this chapter, we 
exemplify the mechanism behind it, step by step, on the predicate \disp{stop\_thread}, 
discussed in Section~\ref{sec:cintro:example} on page~\pageref{cor:example:body}. 
We consider the \disp{true} execution 
scenario, apply our analysis and compare the actual obtained correlation results with 
the targeted ones depicted in Figure~\ref{cor:example:results}.

\definecolor{indianred}{rgb}{0.90, 0.80, 0.71} %melon
\definecolor{burg}{rgb}{0.8, 0.36, 0.36}
\tikzstyle{vertex} = [ellipse, fill=lightgray!50, minimum size =30pt, inner sep = 0pt]
\tikzstyle{lvertex} = [circle, fill=lightgray!50, minimum size=30pt, inner sep=0pt]
\tikzstyle{ivertex} = [circle, draw=red, minimum size=30pt, inner sep = 0pt]
% \tikzstyle{edge} = [draw, semithick, -> ] 
\tikzstyle{edgeRed} = [draw=red!50!black, dashed, thick, -> ] 
\begin{figure}[hbt]\centering
\begin{tabular}{@{}c@{}}
\toprule
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.2cm, semithick,
    statt/.style={scale=0.7,fill=lightgray!50,draw=none,text=black,ellipse,inner sep=0pt,minimum width=.7cm,minimum height=.7cm},
    stattedge/.style={draw, semithick, -> }]
%
   \node[statt]         (N1)  {\large {1: ta := in.threads}};
   \node[statt]         (N2) [below=1cm of N1] {\large {2: th := ta[i]}};
   \node[statt]         (N3) [below left=of N2] {\large {3: $\boldsymbol{switch}$(th) $\boldsymbol{as}$ 
                             [ $\ver$ti}]};
   \node[statt]         (N4) [below=1cm of N3]{\large {4: s := Blocked}};
   \node[statt]         (N5) [below=1cm of N4]{\large {5: ti := \{ti with current\_state = s\}}};
   \node[statt]         (N6) [below=1cm of N5]{\large {6: th := Some(ti)}};
   \node[statt]         (N7) [below=1cm of N6]{\large {7: ta := [ta with i=th]}};
   \node[statt]         (N8) [below=1cm of N7]{\large {8: o := \{in with threads=ta\}}};
   \node[statt]         (N9) [below=1cm of N8]{9: \lbtrue};
   \node[statt]         (N10) [right=6cm of N9]{10: \textsf{inval}};
   %\node[statt]         (N4) [below right=of N2]{\textsf{oob}};
   %\node[statt]         (N5) [below left=of N3]{\lbtrue};
   %\node[statt]         (N6) [below right=of N3]{\textsf{None}};  
   \path (N1) edge[stattedge]       node {\large {\lbtrue}} (N2);
   \path (N2) edge[stattedge]       node {\large {\lbtrue}} (N3);
   \path (N3) edge[stattedge]       node {\large {\lbtrue}} (N4);
   \path (N4) edge[stattedge]       node {\large {\lbtrue}} (N5);
   \path (N5) edge[stattedge]       node {\large {\lbtrue}} (N6);
   \path (N6) edge[stattedge]       node {\large {\lbtrue}} (N7);
   \path (N7) edge[stattedge]       node {\large {\lbtrue}} (N8);
   \path (N8) edge[stattedge]       node {\large {\lbtrue}} (N9);
   \path (N2) edge[stattedge,-,out=-50,in=90]       node[pos=0.35] {\large {\lbfalse}} (N10);
   \path (N7) edge[stattedge,-,out=0,  in=90]       node[pos=0.35] {\large {\lbfalse}} (N10);
   \path (N3) edge[stattedge,  out=-30,in=90]       node[pos=0.35] {\large {\textsf{None}}} (N10);
   %\path (N2) edge[stattedge]              node[xshift=-0.8cm,yshift = 0.4cm] {\large{\lbtrue}} (N3);
   %\path (N2) edge[stattedge]              node {\large {\lbfalse}} (N4);
   %\path (N3) edge[stattedge]              node[left, anchor=south east] {\large {\textsf{Some}}} (N5);
   %\path (N3) edge[stattedge]              node[right, anchor=south west] {\large {\textsf{None}}} (N6);

\node(c10)[draw=burg,dotted,scale = 0.7, left=of N10,xshift=1.6cm] {
\begin{tabular}{c}
 $ \mathit{Unreachable} $\\
\end{tabular}
};

\node(c9) [draw=caribbeangreen, scale = 0.8, left=of N9] {
\begin{tabular}{c}
\textsf{(o, o\#)} $\mapsto$ $\{(\pempty,\pempty) \mapsto \equal\}$\\
\end{tabular}
};

\end{tikzpicture}\\
\bottomrule
\end{tabular}
\caption{Analysing Predicate \disp{stop_thread} -- Initialisation}
\label{intra:cor:init}
\end{figure}

Since a predicate can only exit with one label at a time and we are analysing the
\disp{true} label, we can map the exit node \disp{inval} to the special case 
\emph{Unreachable}. We begin by initialising the correlation summary for the exit 
node corresponding to the \disp{true} exit label. As shown in Figure~\ref{intra:cor:init}, 
this consists in mapping the pair referring to the \emph{local} value of the \disp{o} 
variable and the \emph{final} state of \disp{o}, 
to a correlation map containing a single correlation, namely 
$(\pempty, \pempty) \mapsto \equal$. This acknowledges that the value of the output \disp{o}
retrieved to the predicate's callers is the most recent value computed locally. 
In the following, we denote the final value of 
\disp{o} by \disp{o#} in order to distinguish it from the local value.

%\pagebreak
We advance backwards along the control flow graph, reaching node 8. We apply the 
equation corresponding to a field access as given in Table~\ref{ch7:representation}  
and obtain the following correlation summary:
\newcommand{\tsf}[1]{\textsf{#1}}
%
\[
\begin{array}{rll}
(\tsf{in}, \tsf{o}) &\mapsto 
           &\left\{ (\pempty, \pempty) \mapsto
           \left\{\begin{array}{rll}
           \textrm{\tsf{threads}} &\mapsto &\qmark \\
           \textrm{\tsf{pid}} &\mapsto &\equal \\
           \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
           \textrm{\tsf{adr\_space}} &\mapsto&\equal
           \end{array}\right\}\right\} \\\\
(\tsf{ta},\tsf{o}) & \mapsto &\{(\pempty, .\tsf{threads}) \mapsto \equal\}
\end{array}.
\]
% 
\noindent We compose it with the correlation summary of its successor node, i.e. the
exit node corresponding to the \disp{true} exit label, thus detecting the flow
of \disp{in} to \disp{o#} and of \disp{ta} to \disp{o#} respectively, through 
the local value \disp{o}. This amounts to:
\[
\begin{array}{rll}
(\textsf{in}, \textsf{o\#}) &\mapsto 
           &\left\{ (\pempty, \pempty) \mapsto
           \left\{\begin{array}{rll}
           \textrm{\tsf{threads}} &\mapsto &\qmark \\
           \textrm{\tsf{pid}} &\mapsto &\equal \\
           \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
           \textrm{\tsf{adr\_space}} &\mapsto&\equal
           \end{array}\right\}\right\} \\\\
(\tsf{ta}, \tsf{o\#}) & \mapsto &\{(\pempty, .\tsf{threads}) \mapsto \equal\}
\end{array}.
\]   
Since node 8 does not have any other successor nodes, the correlation 
information at its entry point is identical to the one we have just computed.

We advance one step, reaching node 7 and apply the corresponding equation,
thereby obtaining:
\[
\begin{array}{rll}
(\tsf{ta}, \tsf{ta}) &\mapsto 
           &\left\{ (\pempty, \pempty) \mapsto \aerel{\equal}{i}{\qmark}
            \right\} \\\\
(\tsf{th}, \tsf{ta}) & \mapsto &\{(\pempty, \pcell) \mapsto \equal\}
\end{array} .
\]
We compose it with the correlation summary of node 8, tracking the flow of the 
\emph{local} value of \disp{ta} to \disp{o#}, through the \emph{new} state of the 
variable \disp{ta}, after updating its \disp{i}-th element. We also track the flow
of \disp{th} to \disp{o#}. The correlation map for the $(\tsf{in},\tsf{o\#})$ pair remains 
unchanged. We thus obtain:
\[
\begin{array}{rll}
(\tsf{in}, \tsf{o\#}) &\mapsto 
           &\left\{ (\pempty, \pempty) \mapsto
           \left\{\begin{array}{rll}
           \textrm{\tsf{threads}} &\mapsto &\qmark \\
           \textrm{\tsf{pid}} &\mapsto &\equal \\
           \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
           \textrm{\tsf{adr\_space}} &\mapsto&\equal
           \end{array}\right\}\right\} \\\\
(\tsf{ta}, \tsf{o\#}) & \mapsto &\{(\pempty, .\tsf{threads}) \mapsto \aerel{\equal}{i}{\qmark}\\\\
(\tsf{th}, \tsf{o\#}) & \mapsto &\{(\pempty, .\tsf{threads}\pcell) \mapsto \equal\}
\end{array}.
\]  
In order to obtain the correlation information at the entry point of node 7,
we need to join the computed correlation summary with the correlation summary
known for the other successor of node 7, namely the exit node 10. Since the 
latter is \emph{Unreachable}, the identity element for join at the intraprocedural 
level, it does not affect the correlation summary at the entry point of node 7.
We proceed similarly for nodes 6, 5, 4, 3 and 2, applying the corresponding data-flow 
equation for each statement and composing with the intraprocedural correlation 
summary of the successor node. Since each of these nodes has only one possible
exit label there are not multiple contributions that need to be joined. At the 
entry point of node 6, for example we obtain the following summary:
\[
\begin{array}{rll}
%% (\tsf{in},\tsf{o\#}) &\mapsto 
%%            &\left\{ (\pempty, \pempty) \mapsto
%%            \left\{\begin{array}{rll}
%%            \textrm{\tsf{threads}} &\mapsto &\qmark \\
%%            \textrm{\tsf{pid}} &\mapsto &\equal \\
%%            \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
%%            \textrm{\tsf{adr\_space}} &\mapsto&\equal
%%            \end{array}\right\}\right\} \\\\
(\tsf{ta}, \tsf{o\#}) & \mapsto &\{(\pempty, .\textrm{\tsf{threads}}) \mapsto \aerel{\equal}{i}{\qmark}\\\\
(\tsf{ti}, \tsf{o\#}) & \mapsto &\{(\pempty, .\textrm{\tsf{threads}}\pcell@\textrm{\tsf{Some.t}}) \mapsto \equal\}\\
\end{array}
\]
\[
\begin{array}{rll}
(\tsf{in},\tsf{o\#}) &\mapsto 
           &\left\{ (\pempty, \pempty) \mapsto
           \left\{\begin{array}{rll}
           \textrm{\tsf{threads}} &\mapsto &\qmark \\
           \textrm{\tsf{pid}} &\mapsto &\equal \\
           \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
           \textrm{\tsf{adr\_space}} &\mapsto&\equal
           \end{array}\right\}\right\} \\\\
%% (\tsf{ta}, \tsf{o\#}) & \mapsto &\{(\pempty, .\textrm{\tsf{threads}}) \mapsto \aerel{\equal}{i}{\qmark}\\\\
%% (\tsf{ti}, \tsf{o\#}) & \mapsto &\{(\pempty, .\textrm{\tsf{threads}}\pcell@\textrm{\tsf{Some.t}}) \mapsto \equal\}\\\\
\end{array}.
\]
We skip some steps and obtain the following correlation summary at the entry
point of node 2:

\begin{center}%
  \scalebox{0.9}{%
    \parbox{\linewidth}{%
      \[
      \begin{array}{rll}
        (\tsf{in},\tsf{o\#}) &\mapsto 
        &\left\{ (\pempty, \pempty) \mapsto
          \left\{\begin{array}{rll}
                   \textrm{\tsf{threads}} &\mapsto &\qmark \\
                   \textrm{\tsf{pid}} &\mapsto &\equal \\
                   \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
                   \textrm{\tsf{adr\_space}} &\mapsto&\equal
                 \end{array}\right\}\right\} \\\\
        (\tsf{ta}, \tsf{o\#}) & \mapsto 
        &\left\{\begin{array}{rll}
                  (\pempty, .\textrm{\tsf{threads}}) &\mapsto &\aerel{\equal}{i}{\qmark}\\
                  (\pcell\tsf{@Some.t}, \tsf{.threads}\pcell\tsf{@Some.t}) &\mapsto
                                                              &\left\{\begin{array}{rll}
                                                                        \tsf{id} &\mapsto &\equal\\
                                                                        \tsf{current\_state}&\mapsto&\qmark\\
                                                                        \tsf{stack} &\mapsto&\equal\\
                                                                      \end{array}\right\}
                \end{array}\right\}
              % (\pempty, .\textrm{\tsf{threads}}) \mapsto \aerel{\equal}{i}{\qmark}\\\\
      \end{array}.
      \]%
    }%
  }%
\end{center}

Finally, we reach node 1, where we apply the data-flow equation corresponding to a
field access and compose the obtained information with the correlation summary 
computed at the entry of node 2. We obtain:

\begin{center}
  \scalebox{0.85}{%
    \parbox{\linewidth}{%
      \[
 \hspace{-0.7cm}     \begin{array}{rll}
        (\tsf{in},\tsf{o\#}) &\mapsto 
        &\left\{ 
          \begin{array}{rll}
            (\pempty, \pempty) &\mapsto
            &\left\{\begin{array}{rll}
                      \textrm{\tsf{threads}} &\mapsto &\qmark \\
                      \textrm{\tsf{pid}} &\mapsto &\equal \\
                      \textrm{\tsf{crt\_thread}} &\mapsto &\equal \\
                      \textrm{\tsf{adr\_space}} &\mapsto&\equal
                    \end{array}\right\} \\\\
            (.\textrm{\tsf{threads}}, .\textrm{\tsf{threads}}) &\mapsto &\aerel{\equal}{i}{\qmark}\\\\
            (.\textrm{\tsf{threads}}\pcell\tsf{@Some.t}, \tsf{.threads}\pcell\tsf{@Some.t}) &\mapsto
            &\left\{\begin{array}{rll}
                      \tsf{id} &\mapsto &\equal\\
                      \tsf{current\_state}&\mapsto&\qmark\\
                      \tsf{stack} &\mapsto&\equal\\
                    \end{array}\right\}\\\\
          \end{array}\right\}
      \end{array}
      \]%
    }%
  }%
\end{center}

Since the node 1 has only one successor node, this correlation summary represents
the correlation information at the entry point of node 1, i.e. there is no other
correlation summary to join it with. This contains a single pair of variables,
(\tsf{in}, \tsf{o\#}) and their associated correlation map. Since the pair is
an input-output pair of the \disp{stop_thread} predicate, we do not need to 
filter anything out. This constitutes the final correlation summary for the
analysed predicate on the \disp{true} exit label. These results are identical to 
the ones we had depicted as our targeted results in Figure~\ref{cor:example:results}. 

For the \disp{inval} exit label, the corresponding correlation summary is 
\emph{NoCorrelation}. This example can be
tried on the web page\footnote{Correlation Analysis Web Page: \url{http://www.ajl-demo.fr/2016/}} 
dedicated to our correlation analysis. Other examples are provided and explained
there as well. Additionally, users can devise and test their own examples. 


\section{Experimental evaluation on a verified micro-kernel}

This section describes an experimental evaluation of the dependency
and correlation analyses on the formal verification of a
micro-kernel. 
{\pcore}~\cite{lescuyer15} is one of the two microkernels entirely 
specified and developed in {\slang} at {\prun}. Unlike Minix 3.1 by which 
it was inspired, {\pcore} targets 
ARM architectures and uses a Memory Management Unit for managing virtual 
address spaces. It is a general-purpose microkernel supporting creation 
and deletion of processes, execution of programs, synchronous message-passing 
inter-process communication with timeouts, asynchronous notifications, and 
process-to-process data copies. %ProvenCore has a shared memory system. 

The main property ensured by {\pcore} is the isolation property. Isolation 
implies two complementary properties, namely integrity and 
confidentiality. Integrity refers to ensuring that the resources of a process
(its code, data, and registers) cannot be altered or interfered with by other
processes, unless explicitly authorized by the process. Confidentiality
refers to ensuring that the resources of a process cannot be observed
by other processes, unless explicitly authorized by the process. In other words,
integrity ensures that until a process decides to communicate with other 
processes, it will execute as if it were alone on the system. 
Confidentiality ensures that as long as a process does not send its secrets to 
other processes, it can change its secrets without affecting other processes.    

The isolation property has been formally proven using the interactive proof
assistant of {\ptools}. The proofs also establish functional specifications
verified by {\pcore}~\cite{lescuyer15}.

The proof for the isolation property is based on multiple refinements between 
successive models, from the most abstract, on which the \emph{isolation} 
property is defined and proven, to the most concrete, i.e. the actual model 
used for code generation. These successive models are shown in 
Figure~\ref{fig:pcore:layers}.
 
\begin{figure}[hbtp]\centering
\begin{tikzpicture}
  [node distance=.8cm,
  start chain=going below,]
     \node[punktchain,fill=caribbeangreen!20, join] (spm)      {SPM};
     \node[punktchain,fill=caribbeangreen!40, join] (rsm)      {RSM};
     \node[punktchain,fill=caribbeangreen!60, join] (fsp)      {FSP};
     \node[punktchain,fill=caribbeangreen!80, join] (tds)      {TDS};
  \end{tikzpicture}
\caption{{\pcore} -- Abstract Layers}
\label{fig:pcore:layers}
\end{figure}

Using multiple abstract models, each more abstract than its predecessor, enables
a degree of separation of concerns in the overall proof. The lower-level proofs
include a plethora of low-level properties and invariants, and are devoid of 
functional properties, while the higher-level models focus on functional 
specifications. Each layer of abstraction removes details that are not relevant
for it anymore and enables changing the representation of the transition system
in order to internalize in the structure of its states some invariants of the 
preceding level.

The \emph{Security Policy Model} (SPM) is the most abstract level and the one
at which the isolation property is expressed and proven. The kernel is modeled
as an abstract controller and the various processes are modeled as machines, 
each possessing its own independent physical resources.

The \emph{Refined Security Model} (RSM) is an intermediate layer, meant to 
bridge the wide gap between its successor, the SPM and its predecessor, the FSP. 
In the RSM, the machines share
the same physical resources, which are managed by the controller.

The \emph{Functional Specifications} (FSP) layer is a model roughly equivalent
to its predecessor -- the TDS -- in functionality, but unlike the latter it uses
data structures and algorithms that facilitate reasoning and formal proof. Its
main functional difference with the TDS is that it eliminates MMU address
translation, using instead a linear view of the RAM, similarly to the RSM.

The \emph{Target of Evaluation Design} (TDS) is the model that is used to generate
the sequential {\slang} code of the kernel, as well as the models for hardware
components that are not translated into C code, but which are necessary for
completing the TDS specifications.

For each refinement, a \emph{view}, i.e. a function from the concrete model
state to the abstract model state, is defined. Then, a correspondence or
commutation lemma is proven, establishing that transitions from $c$ to $c'$
in the concrete model entail transitions from the view of $c$ to the view of
$c'$ in the abstract model. Since the views are not total functions, this
requires showing that the views actually exist. In this manner, the higher
levels are attained, reaching models that are simpler and more flexible than
the TDS but that still simulate all its possible
behaviours~\cite{lescuyer15}.

This refinement chain also facilitates reusing parts of one proof effort in 
other proofs.

\subsection{Obtained Dependency and Correlation Results}\label{ch9:tstats} 

Our dependency and correlation analyses must be evaluated by two different
criteria, namely execution time and precision. In this section we are discussing the
former. The latter will be discussed in the following section.

Both analyses target complex transition systems in general, and operating systems
in particular. The ideas behind them stemmed directly from the verification effort
entailed by {\pcore}. Unlike other static analyses, which are frequently employed 
in a fully automatic setting, our static analyses are supposed to be used as 
companion tools in the middle of interactive program verification. They are supposed
to be applied often, as steps during interactive proofs. For instance, the dependency
and correlation summaries for different predicates might be needed for verifying a 
single property. These in turn may imply a whole-model analysis. Therefore, the 
dependency and correlation analyses must perform quickly in order to answer effectively
``questions'' asked frequently. 

Our analyses have currently been applied to the functional specification of
{\pcore}~\cite{lescuyer15}. More specifically, they have been
applied to the RSM, FSP, and TDS layers shown in
Figure~\ref{fig:pcore:layers}. Each of these layers is characterized by a global
state with numerous fields, and different transitions, i.e. supported commands
or system calls such as \emph{fork, exec, exit}. Each supported command receives
as an input the global state before the transition and returns the state of the
system after the transition.

For instance, in RSM the global states are much simpler compared to the ones in the layers
below it, i.e. FSP and TDS. They are
modeled by a structure with 6 fields, out of which 3 are modeled by arrays and 2
by structures. The RSM counterpart of the optional table of processes is a store
of machines, which are themselves the counterpart of FSP processes. Machines are
structures with 7 fields that refer to registers, information regarding 
inter-process communication or permissions, and code and data segments. Out of the 
7 fields, 2 are modeled by variants, 2 by associative arrays and other 2 by
structures. 

The global state of the FSP layer is modeled by a structure type with
15 fields, including fields that concern process management (for memory allocations,
information about processes), interrupt handling (registered handlers, active handlers),
scheduling (priority queues, currently running process, process to run next), time
management or code data. Among these 15 fields, 9 fields are ``composite'' themselves, being  
modeled by structures, variants or associative arrays. For instance, among the fields 
concerning process management, there is a table of optional processes. The processes 
themselves are modeled by a structure type having 26 fields. Out of the total of 26 
fields, 11 are modeled by algebraic data structures or associative arrays too. 

The FSP global state is characterized by over 70 invariants. %There are ... possible 
%transitions. 
 
%The state is characterized by ... invariants. There are ... possible transitions.

In TDS, the global state is a structure having 33 fields, among which 23 are 
``composite'' as well. The processes are structures having 29 fields, among which
14 are modeled by associative arrays or algebraic data types. The global state
is characterized by approximately 140 invariants.

In Table~\ref{res:fspstate} we give an overview of the global states for each
analysed layer. The first column shows the total number of fields. The second
column indicates the number of fields that are modeled by associative arrays.
Between parentheses we indicate the number of arrays having ``composite'' elements
and elements of atomic or implicit types, respectively. For example, the FSP global
state has 6 fields that are modeled by associative arrays and all 6 of them have
``composite'' elements. In columns 3, 4, and 5 we show the number of fields that
are modeled by structures, variants and atomic or implicit types, respectively.  


\begin{table}[hbtp]
\caption{{\pcore} Abstract Layers -- Global State Type}
\centering
\begin{tabular}{cccccc} \toprule
    {}       & {Global State} &{Arrays}          & {Structures} & {Variants}     & {Atomic/Implicit}  
    \\ \midrule
    RSM      & 6 fields       & 2 fields (1/1)    & 2 fields     &  0 fields      & 2 fields        \\
    FSP      & 15 fields      & 6 fields (6/0)    & 0 fields     &  3 fields      & 6 fields         \\ 
    TDS      & 33 fields      & 14 fields (14/0)  & 3 fields     &  6 fields      & 10 fields        \\\bottomrule\\
\end{tabular}
\label{res:fspstate}
\end{table}

The global state of each layer contains an array or store of processes or machines.
In Table~\ref{res:fspproc} we give an overview of the process or machine type for 
each analysed layer. The table has the same structure as the one described 
previously for the global state types.


\begin{table}[hbtp]
\caption{{\pcore} Abstract Layers -- Process/Machine Type}
\centering
\begin{tabular}{cccccc} \toprule
    {}       & {Process/Machine} &{Arrays}        & {Structures} & {Variants}    & {Atomic/Implicit}  
    \\ \midrule
    RSM      & 7 fields          & 2 fields (1/1)   & 2 fields     & 2 fields      & 1 field          \\
    FSP      & 26 fields         & 2 fields (0/2)   & 5 fields     & 3 fields      & 16 fields        \\ 
    TDS      & 29 fields         & 1 field  (1/0)   & 8 fields     & 5 fields      & 15 fields         \\ \bottomrule\\
\end{tabular}
\label{res:fspproc}
\end{table}

We have applied our dependency and correlation analyses on the RSM, FSP, and TDS 
layers, thus conducting medium-sized experiments. An overview of the characteristics 
for the 3 {\pcore} layers is included in Table~\ref{res:statsdep1}, 
Table~\ref{res:statsdef1}, and Table~\ref{res:statscor1}. In each of these, the first 
column shows the total number of predicates of the analysed layers. In parentheses, we 
indicate the number of predicates that only read information and return a 
Boolean-like exit label, i.e. logical 
properties, as well as the number of implicit predicates for which a 
pessimistic assumption is made. The second column shows the total number 
of lines of code (LoC) for each, including comments and type definitions. 
The next three columns indicate the number of LoC 
corresponding to predicates, type definitions and comments, respectively.

We have run the analyses 101 times in a loop on a Lenovo laptop with a Quad-Core  
Intel Core I7-5500U processor and 8 GB RAM. The system runs Xubuntu Gnu/Linux 64 bit, 
Release 15.10 with OCaml 4.01. Before the first run of each loop the operating 
system's cache was dropped using the following command:

\begin{center}\texttt{echo 3 > /proc/sys/vm/drop\_caches}\end{center}

The time measured includes only the execution of the analysis algorithms. It
excludes the time required to load the input files, as well as the time spent
printing the results.

% The maximum and average times, denoted by Max* and Avg*, respectively in the 
% tables exclude the first run. 
% When running the analysis during interactive program proving, the analyser 
% executable and the program to be analysed should both be already loaded in memory, 
% at the beginning of the interactive session, hence the exclusion of the first run 
% in these figures.
% The minimum times and other percentiles shown
% in Table~\ref{res:statsdep2}~\ref{res:statsdef2},~and~\ref{res:statscor2} were
% computed including the first run.
% The first run shown in the first column of 
% Table~\ref{res:statsdep2},~\ref{res:statsdef2},~and~\ref{res:statscor2} was
% always slower than all other runs.

On average, our fully context-insensitive dependency analysis as presented in
Chapter~\ref{chapter5} computed the dependency summaries for 633 RSM/FSP predicates in
0.656 seconds. For the TDS predicates, the dependency summaries were computed in
0.699 seconds on average. These results are indicated in Table~\ref{res:statsdep1}.

\begin{table}[hbtp]
\caption{Abstract Layers -- Evaluation Data and Dependency \mbox{Analysis} Timing}
\centering
\begin{tabular}{@{}cc@{\hspace{0.5\tabcolsep}}ccccc@{}} \toprule
    {}      & {Predicates}  & {Total LoC} & {Code} & {Types} & {Comments} & {Dependency Avg}  
                                                                                    \\ \midrule
    RSM/FSP & 633 (235/65)  & 9853        & 8402   & 596     & 855        & 0.656 s \\ \midrule
    TDS     & 780 (231/155) & 14000       & 11306  & 588     & 2106       & 0.699 s \\ \bottomrule\\
\end{tabular}
\label{res:statsdep1}
\end{table}

In Table~\ref{res:statsdep2} we indicate the minimum and maximum execution times
for the context-insensitive dependency analysis. Various percentiles
are indicated as well. 

\begin{table}[hbtp]
\caption[Abstract Layers -- Detailed Dependency Analysis Timing]
{Abstract Layers -- Detailed Dependency Analysis Timing (in seconds)}
\centering
\begin{tabular}{cccccccc} \toprule
    {}  & {Min} & {10\%ile} & {50\%ile} & {90\%ile} & {Max} & {Avg} \\ \midrule
RSM/FSP & 0.650 & 0.651     & 0.652     & 0.658     & 0.730 & 0.656 \\ \midrule
TDS     & 0.690 & 0.691     & 0.693     & 0.718     & 0.798 & 0.699 \\ \bottomrule\\
\end{tabular}
\label{res:statsdep2}
\end{table}

The average execution time of our dependency 
analysis with the deferred accesses extension is shown in Table~\ref{res:statsdef1},
in the last column denoted by Avg. On average, our dependency analysis extended with
deferred accesses, as presented in Chapter~\ref{chapter6}, computed the dependency 
summaries with context-sensitive leaves for 633 predicates in
0.779 seconds. For the TDS predicates, the dependency information was computed in
0.919 seconds on average. These results are indicated in Table~\ref{res:statsdef1}.

Therefore, using our relaxed form of context-sensitivity led to an increase of 
\mbox{10-20\%} in execution time on the used benchmarks.  

\begin{table}[hbtp]
\caption{Abstract Layers -- Evaluation Data and Deferred Dependency Analysis Timing}
\centering
\begin{tabular}{ccccccc} \toprule
    {}      & {Predicates}  & {Total LoC} & {Code} & {Types} & {Comments} & {Deferred Avg}  
                                                                                    \\ \midrule
    RSM/FSP & 633 (235/65)  & 9853        & 8402   & 596     & 855        & 0.779 s \\ \midrule
    TDS     & 780 (231/155) & 14000       & 11306  & 588     & 2106       & 0.919 s \\ \bottomrule\\
\end{tabular}
\label{res:statsdef1}
\end{table}

The detailed timing information for the dependency analysis using deferred accesses
is shown in Table~\ref{res:statsdef2}.

\begin{table}[hbtp]
\caption[Abstract Layers -- Detailed Deferred Dependency Analysis Timing]
{Abstract Layers -- Detailed Deferred Dependency Analysis Timing (in seconds)}
\centering
\begin{tabular}{cccccccc} \toprule
    {}  & {Min} & {10\%ile} & {50\%ile} & {90\%ile} & {Max} & {Avg} \\ \midrule
RSM/FSP & 0.776 & 0.777     & 0.779     & 0.781     & 0.785 & 0.779 \\ \midrule
TDS     & 0.904 & 0.905     & 0.908     & 0.975     & 0.999 & 0.919 \\ \bottomrule\\
\end{tabular}
\label{res:statsdef2}
\end{table}

The average execution time of our correlation
analysis is shown in Table~\ref{res:statscor1}, in the last column denoted by
Avg. The correlation summaries for the RSM/FSP predicates are computed in
0.426 seconds on average. For the TDS predicates, the correlation summaries are
computed in 0.496 seconds on average.
Unlike the dependency analysis which computes information for code as well as
specifications, i.e. logical properties, in a unified manner, the correlation analysis
only computes information for predicates that actually modify data structures.
This partly explains the time difference between the two analyses. We also remark that
the possible-constructors analysis is performed simultaneously with the dependency 
analysis and this contributes to the difference between the execution times as well. 

\begin{table}[hbtp]
\caption{Abstract Layers -- Evaluation Data and Correlation Analysis Timing}
\centering
\begin{tabular}{@{}cc@{\hspace{0.5\tabcolsep}}ccccc@{}} \toprule
    {}      & {Predicates}  & {Total LoC} & {Code} & {Types} & {Comments} & {Correlation Avg}  
                                                                                    \\ \midrule
    RSM/FSP & 633 (235/65)  & 9853        & 8402   & 596     & 855        & 0.426 s \\ \midrule
    TDS     & 780 (231/155) & 14000       & 11306  & 588     & 2106       & 0.496 s \\ \bottomrule\\
\end{tabular}
\label{res:statscor1}
\end{table}

The detailed timing information for our correlation analysis is shown in Table~\ref{res:statscor2}.

\begin{table}[hbtp]
\caption[Abstract Layers -- Detailed Correlation Analysis Timing]
{Abstract Layers -- Detailed Correlation Analysis Timing (in seconds)}
\centering
\begin{tabular}{cccccccc} \toprule
    {}  & {Min} & {10\%ile} & {50\%ile} & {90\%ile} & {Max} & {Avg} \\ \midrule
RSM/FSP & 0.424 & 0.425     & 0.425     & 0.427     & 0.432 & 0.426 \\ \midrule
TDS     & 0.492 & 0.493     & 0.494     & 0.498     & 0.540 & 0.496 \\ \bottomrule\\
\end{tabular}
\label{res:statscor2}
\end{table}

Generally, static analysis has been considered prohibitive in terms of execution
time and it has been avoided in an interactive context and used predominantly
in an automatic context. Though currently applied only on medium-sized models, 
the execution times of both of our analyses are short enough to expect reasonable 
execution times for larger models as well\footnote{It is noteworthy to remark that
the interprocedural dependency and correlation summaries will not necessarily be
computed on-the-fly, during the interactive proof. They rather will be computed
as part of the build. In contrast, the treatment of a query, once all interprocedural 
information has been computed, will be executed in real-time. Nevertheless, it is desirable
to have fast analyses, allowing developers to iterate frequently.}.  

% It is noteworthy to remark that the execution time for both the dependency and the
% correlation analysis is consistent across all runs and varies only by a few 
% miliseconds.

\subsection{Precision of our Dependency and Correlation Summaries}~\label{ch9:res:precision}

In this section we try to illustrate the sort of dependency and correlation
summaries that are computed by our analyses. We conclude the section with a
brief discussion regarding the precision of our obtained results. Assessing
and discussing precision as a metric for usefulness is hard in isolation and
can only be effectively done in relation to actual applications.
% in the absence of actual applications.
However, we present some statistics in order to give some
insight about the proportion of the non-trivial information computed. For our
current discussion we focus on the results obtained on the RSM/FSP and the TDS 
layers.
%which included 633 predicates.

One of the analysed predicates of the RSM/FSP layers is \disp{do_auth}. This
predicate is a system call clearing or granting an authorization to some
process to read from or write to some memory range of the current process. It
receives a global state \disp{in} and an index \disp{i} as inputs and
produces, on the \disp{true} label, the new global state \disp{out}, after
modifying the permission for the \disp{i}-th process in the process store.

The code of {\disp{do_auth}} performs various system-wide checks before 
registering the permission change, and is therefore not trivial, although its 
effect is quite limited. Indeed, the correlation results computed by our analysis 
for the \disp{true} label of this predicate are shown below. 

\phantom{a}

\def\mto{\mapsto}
\definecolor{pgreen}{rgb}{0.00, 0.42, 0.24}
\setlength{\jot}{1.5pt}
$\textrm{\disp{true}}: (\textrm{\disp{in}}, \textrm{\disp{out}}) \mto [$\\[\jot]
\begin{minipage}{.2\textwidth}
$
%\textrm{\disp{true}}: (\textrm{\disp{in}}, \textrm{\disp{out}}) \mto [\\[\jot]
  \begin{array}{r*{9}l}
    (\pempty, \pempty) 
    &\mto\{ &\textrm{\disp{...}} &\mto 
    &\equal \phantom{\}} & &&&
    & \left.\hspace{-3.7cm}\color{pgreen}\right\}\textrm{\textcolor{pgreen}{\textrm{\small 14 fields}}} \\[\jot]  
     
    & &\textrm{\disp{procs}} &\mto &\qmark \,\,\,\} & &&&&  \\[\jot]   

    (\textrm{\disp{.procs}}, \textrm{\disp{.procs}}) 
    &\mto\langle &\equal\triangleright \textrm{i} &: 
    &[\textrm{ \disp{None}} &\mto &\equal&&\\[\jot]
 
    & & & 
    &\textrm{\phantom{ [}\disp{Some}} &\mto &\{\textrm{\disp{v}}\mto\{
    &\textrm{\disp{...}}&\mto&\equal\phantom{\}} 
    \left.\hspace{-0.25cm}\color{pgreen}\right\}\textrm{\textcolor{pgreen}{\textrm{\small 25}}}\\[\jot]
    
    &&&
    &&&
    &&&\hspace{0.75cm}\textrm{\textcolor{pgreen}{\textrm{\small fields}}}\\[\jot]

    & & & 
    & & &
    &\textrm{\disp{mem_auth}}&\mto&\qmark\}\}]\rangle]\\[\jot]

  \end{array}
$
\end{minipage}%
%

\phantom{a}

\noindent The analysis detects 
that out of the 15 fields of \disp{out}, only the \disp{i}-th element of the 
\disp{procs} field is changed. Furthermore, it detects that if this element is an 
active process, i.e. built with the \disp{Some} constructor, only the \disp{mem_auth} 
field is modified out of the total of 26 fields. Everything else is copied from the input 
state \disp{in}.

Combined with dependency summaries for logical properties, this correlation summary 
would allow us to infer the preservation of all invariants that are not concerned 
with the memory permissions. All but one out of the specified properties for the global
state fall into this category. This is the \emph{relevant memory permissions} property:

\phantom{a}

\indent\indent\indent\indent \disp{predicate proc_mem_auth_ok(proc proc) -> [true | false]}
 
\phantom{a}

\noindent which verifies a fundamental property that has to hold for all processes in the 
process store of {\disp{proc}} and states that a process has permissions covering a valid 
range of memory addresses and referring only to existing processes.  
After executing \disp{do_auth}, this property is threatened and 
needs to be verified only for the \disp{i}-th process of the store. It is preserved for 
all others.
   
The dependency results computed by our analysis for this predicate are
shown below. The analysis detects that for each of the possible
execution scenarios, the outcome depends only on 2 out of the 26
fields, namely the stackframe and the memory permissions. The
dependency on the {\disp{stackframe}} is confined to only one of the 3
fields: the data and stack segment. The memory permissions are given
by a variant with 3 constructors, denoting reading and writing
permissions or the absence of any permission. Furthermore, besides
pinning down the outcome's dependency on 2 out of the 26 fields of the
{\disp{proc}} structure, the analysis also detects that the absence
of any memory permission, indicated by the constructor {\disp{NONE}}
of the {\disp{mem_auth}} variant, is \impossible{} for the
\textsf{false} execution scenario. In other words, unused permissions
cannot threaten the property \disp{proc_mem_auth_ok}.
\begin{center}
\resizebox{.5\textheight}{!}{%
$
\setlength\arraycolsep{2pt}
\begin{array}{llllllllll}
%false label
& \textrm{\bf false} &\to &\{\mathit{proc} &\to \{&\mathit{mem\_auth} 
&\to [&\mathit{READ} &\to \{&\mathit{base} \to \everything;\; \mathit{len} \to \everything\} \\

&          &       &             &           &&                                
&\mathit{WRITE} &\to \{&\mathit{base} \to \everything; \; \mathit{len} \to \everything\}  \\

&          &       &             &           &&                                
&\cellcolor{lightgray!30}\mathit{NONE} & \to &\mmygbox{\impossible}] \\

&          &       &             &           &\mathit{stackframe} 
&\to \{& \mathit{ds} &\to & \everything \}\}\} \\

%true label
&\textrm{\bf true} &\to & \{proc &\to \{&\mathit{mem\_auth} 
&\to [&\mathit{READ} &\to \{&\mathit{base} \to \everything;\; \mathit{len} \to \everything\} \\

&          &       &             &           &&                                
&\mathit{WRITE} &\to \{&\mathit{base} \to \everything; \; \mathit{len} \to \everything\} \\
&          &       &             &           &&                                
&\cellcolor{lightgray!30}\mathit{NONE} & \to & \mmygbox{\nothing}] \\

&          &       &             &           &\mathit{stackframe} 
&\to \{& \mathit{ds} &\to & \everything \}\}\} 
\end{array}
$}
\end{center}

The \emph{relevant memory permissions} property is thus only threatened by 
transitions that add memory permissions or change a process' virtual space 
layout. Only 2 transitions out of the 25 belong to this category: 
{\disp{exec}} which resets the process' segments, and {\disp{do_auth}} 
which adds permissions and was discussed above. In particular, transitions 
deleting memory permissions 
do not impact the property since the absence of permissions, as shown by the 
dependency of the constructor {\disp{NONE}} for the \textsf{false} label, is 
an impossible case when the property does not hold. This is one of the practical 
advantages of tracking constructor possibilities simultaneously and of extending
the correlation analysis to track the evolution of constructors as well. 
   
In the following, we briefly discuss our dependency summaries obtained on the 
RSM/FSP layer in terms of precision. 
An overview is given in Table~\ref{res:statsprecisiondep}. The first column 
refers to the fully context-insensitive dependency analysis as presented in
Chapter~\ref{chapter5}. The second column refers to the dependency analysis
extended with deferred access maps as presented in Chapter~\ref{chapter6}.
The first line indicates the total number of predicates, both implicit and 
explicit. The second line indicates the total number of implicit predicates
for which we are obliged to make a pessimistic assumption and to consider
everything needed, given that their implementation is hidden. The third line
indicates the number of explicit predicates without inputs for which empty 
summaries are retrieved. Our dependency analysis detects the input subset that
is read in order to obtain the output. In the case of predicates without inputs
this subset is empty. Most explicit predicates without inputs correspond to 
wrapper predicates around calls to constructors that take no arguments. Since 
{\asmil} is an intermediate language, such predicates are automatically generated
and do not necessarily correspond to programmer written predicates.
The next line, line 4, indicates the number of predicates for which we obtain
non-trivial information. By non-trivial information, we mean dependency summaries 
in which the dependency associated to at least one input variable is different
than $\top$, i.e. \textsf{Everything}, the element conveying no information. 
With the context-insensitive dependency analysis, we obtain non-trivial results
for 344 predicates. With the extended dependency we obtain non-trivial results
for 403 predicates.  

\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\newcommand{\tabitemindent}{}

\begin{table}[hbtp]
\caption{RSM/FSP Layers -- Evaluation Data and Dependency \mbox{Summaries}}
\centering
\begin{tabular}{lcc} \toprule
    {}         & {Context-Insensitive} & {Deferred} 
                                                                          \\ \midrule
Number of Total Predicates       & 633                & 633                   \\ \midrule
Number of Implicit Predicates  & 65                 & 65                    \\ \toprule
No Inputs                    & 26                 & 26                    \\\midrule
Number of Non-Trivial Results  & 344                & 403                   \\\midrule
Number of Trivial-Results        & 289                & 230        \\%\midrule
  \tabitem Implicit & \tabitemindent 65  & \tabitemindent 65 \\
  \tabitem No Inputs & \tabitemindent 26  & \tabitemindent 26 \\
  \tabitem Other & \tabitemindent 198 & \tabitemindent 139 \\\midrule
Predicates with Atomic Inputs & 31           & 31                     \\\midrule
Completely Read                    & 71           & 71                     \\\midrule
Overapproximation                  & 96           & 37                     \\ \bottomrule\\
\end{tabular}
\label{res:statsprecisiondep}
\end{table}

The following line --- line 5 --- indicates the total number of predicates for
which trivial results are obtained. These include the results for implicit
predicates, as well as those for predicates without inputs. For the simple
version of the dependency analysis we obtain 198 trivial results, excluding
implicit predicates and predicates without inputs. For the extended
dependency analysis we obtain trivial results for 139 predicates, excluding
implicit predicates and predicates without inputs. Therefore, for the first
version of the analysis, 49 trivial summaries are a consequence of
context-insensitivity. The next 3 lines refer to the 139 predicates for which
trivial results are obtained with both versions of the dependency analysis:
31 of them correspond to predicates manipulating only inputs of atomic types,
such as \texttt{int}. Such inputs are completely read and thus, the trivial
results are justified and do not correspond to an over-approximation.  Other
71 correspond to predicates making complex manipulations and actually reading
all of their input, such as well-formedness checks. The last 37 trivial
results are a consequence of over-approximations made by our analysis. The
majority of them correspond to complex predicates, making multiple calls to
other complex predicates and relying heavily on calls to implicit predicates,
for which conservative assumptions are made. For the simple dependency analysis,
other 46 trivial results are a result of over-approximations related to 
context-insensitivity.
   
An overview of the dependency results for the TDS layer is given in 
Table~\ref{res:statsTDSprecisiondep}. The table follows the same structure as
described for Table~\ref{res:statsprecisiondep}.
%% The dependency summaries obtained with the extended analysis are 
%% considerably more detailed. Just to give an intuition of the difference 
%% between the two, the file containing the results computed with the 
%% context-insensitive dependency analysis contains 7333 lines and its size is
%% 269.4 ko, while the file containing the results computed with the extended
%% analysis contains 11547 lines and its size is 536.5 ko.

\begin{table}[!h]
\caption{TDS Layer -- Evaluation Data and Dependency \mbox{Summaries}}
\centering
\begin{tabular}{lcc} \toprule
    {}         & {Context-Insensitive} & {Deferred} 
                                                                          \\ \midrule
Number of Total Predicates       & 780                & 780                   \\ \midrule
Number of Implicit Predicates  & 155                 & 155                    \\ \toprule
No Inputs                    & 15                 & 15                    \\\midrule
Number of Non-Trivial Results  & 386                & 458                   \\\midrule
Number of Trivial-Results        & 394                & 322        \\%\midrule
  \tabitem Implicit & \tabitemindent 155  & \tabitemindent 155 \\
  \tabitem No Inputs & \tabitemindent 15   & \tabitemindent 15  \\
  \tabitem Other & \tabitemindent 224 & \tabitemindent 152  \\\midrule
Predicates with Atomic Inputs & 49           & 49                      \\\midrule
Completely Read                    & 59           & 59                     \\\midrule
Overapproximation               &116            & 44                     \\ \bottomrule\\
\end{tabular}
\label{res:statsTDSprecisiondep}
\end{table}

We remark that with the deferred dependencies extension, we obtain more
precise dependency summaries for 273 predicates of the RSM/FSP abstract
layer. These constitute approximately 50\% of the predicates in the used
benchmark. For the TDS layer we obtain more precise results for 308 
predicates using the deferred dependencies extension. These constitute 
approximately 50\% of the predicates in the TDS layer for which non-trivial 
results can be obtained (i.e. excluding implicit predicates and those without 
inputs). The dependency summaries obtained with the extended analysis are
considerably more detailed. For instance, just to give an intuition of the 
difference between the results obtained for the TDS layer, the file containing 
the results computed with the
context-insensitive dependency analysis contains 7333 lines and its size is
263.1 kB, while the file containing the results computed with the extended
analysis contains 11547 lines and its size is 523.9 kB. 

The statistics for the correlation analysis are shown in
Table~\ref{res:statsprecisioncor}.  Unlike the dependency analysis, which
handles both logical properties and predicates generating outputs, the
correlation analysis does not handle logical properties.  It tracks
fine-grained partial equivalences between parts of the input and
parts of the output. Therefore, the number of RSM/FSP predicates for which we
can obtain non-trivial results (i.e. at least one partial equivalence between an input 
(sub)element and an output (sub)element, on at least one exit label) is lower. 
Implicit predicates and
specification-only predicates are mapped to \textsf{NoCorrelation}, the
top element conveying no information. Out of the 307 predicates left, we
obtain non-trivial results for 186 of them. The rest include predicates
relying heavily on calls to implicit predicates. They also include complex
system calls such as \texttt{fork} or \texttt{exec} and auxiliary operations
which modify their input entirely.

\begin{table}[!h]
\caption{RSM/FSP Layers -- Evaluation Data and Correlation \mbox{Summaries}}
\centering
\begin{tabular}{lc} \toprule
    {}         & {Correlation Analysis} 
                                                                          \\ \midrule
Number of Total Predicates           & 633                                  \\ \midrule
Number of Implicit Predicates        & 65                                     \\ \toprule
Number of Logical Properties (No Outputs)  & 235\\\midrule
No Inputs                        & 26                                     \\\midrule
Number of Non-Trivial Results    & 186                                   \\\midrule
Number of Trivial-Results            & 90                                   \\
  \tabitem Implicit & \tabitemindent 65                                \\
  \tabitem No Inputs & \tabitemindent 26                                \\
  \tabitem No Outputs & \tabitemindent 235                              \\
  \tabitem Atomic/Implicit Inputs & \tabitemindent 31                             \\\midrule
\end{tabular}
\label{res:statsprecisioncor}
\end{table}

An overview of the correlation results for the TDS layer is given in 
Table~\ref{res:statsTDSprecisioncor}. The table follows the same structure as
described for Table~\ref{res:statsprecisioncor}.

\begin{table}[!h]
\caption{TDS Layer -- Evaluation Data and Correlation \mbox{Summaries}}
\centering
\begin{tabular}{lc} \toprule
    {}         & {Correlation Analysis} 
                                                                          \\ \midrule
Number of Total Predicates           & 780                                  \\ \midrule
Number of Implicit Predicates        & 155                                     \\ \toprule
Number of Logical Properties (No Outputs)  & 231 \\\midrule
No Inputs                        & 15                                     \\\midrule
Number of Non-Trivial Results    & 235                                   \\\midrule
Number of Trivial-Results            & 95                                   \\
  \tabitem Implicit & \tabitemindent 155                                \\
  \tabitem No Inputs & \tabitemindent 15                                \\
  \tabitem No Outputs & \tabitemindent 231                               \\
  \tabitem Atomic/Implicit Inputs & \tabitemindent  49                   \\\midrule
\end{tabular}
\label{res:statsTDSprecisioncor}
\end{table}

\subsection{Reasoning about framing with dependency and correlation analysis}
In general, reasoning about framing relies on the \emph{frame rule}, which is commonly 
illustrated as follows:
\[
\inferrule[]{ \{ P \} C \{ Q \} }
{\{P \wedge R\} C \{Q \wedge R\}}
\]
%
The purpose of the frame rule is to enable local reasoning: a property $R$
that holds for a state $P$, will continue to hold after executing a command
$C$, provided that $R$ reads only locations that are unmodified by $C$.
The frame rule, also called the rule of constancy~\cite{reynolds81},
applies in its original form to simple languages which do not use a heap. 
Separation logic addresses framing for heap-supporting languages. 

In our case, the {\asmil} language with which we are working does not
support mutation. Our work is not concerned with heap modifications but
focuses on deep-state modifications. We handle predicates that receive a 
composite input state and construct a new 
composite output state, without altering the former. The new output state is 
constructed by copying the input state and modifying a subset of subelements. 

In our context, the frame rule must be reinterpreted as follows: a property 
$R$ is preserved by a predicate $C$ receiving 
an input state $P$ and constructing an output state $Q$, if the states $P$ and $Q$ 
agree on the subset on which the property $R$ depends.
%are equal modulo the subset on which the property $R$ does not depend on. 
In other 
words, a property is preserved by a predicate, if the latter only modifies 
subelements on which the property does not depend. Using the terminology used
in separation logic, a property $R$ is preserved by a predicate $C$ if the 
footprint of $C$ is disjoint from the footprint of $R$. However, 
we are not concerned with locations, but with subelements of large states modeled
by algebraic data structures and arrays. Therefore, when reasoning about framing
we need to check if the input subset
modified by an operation is disjoint from the subset that properties are reading 
and depending on. %It is our translation of the frame rule in a certain sense.

We have devised two static analyses for automatically computing the footprints 
of operations and properties. The dependency analysis detects the input subset 
on which the outcome of an operation or of a property relies. The 
correlation analysis detects the input subset that is modified by an operation 
in order to obtain the output. The results of the two analyses are meant to be
used and combined by a decision procedure in order to automatically infer the
preservation of frame properties.   

We  have applied  a  basic  prototype of  the  decision  procedure using  the
dependency  and correlation  summaries  computed for  the  RSM/FSP layers  of
\pcore{}.

% * input data: explain the auto mode
% ** Condition: an input type of the logical property is also an output type of the predicate
% ** any pair of i/o will do, if there are several all were attempted
% ** primitive and implicit types were (manually) excluded from these type(i) = type(o) conditions, based on the assumption that they would rarely succeed (e.g. for int).

Our prototype considers pairs of one  logical property and one predicate. The
logical property  and the predicate must  both operate on values  of the same
type. More precisely,  one of the predicate's  inputs, as well as  one of its
outputs and one of the logical property's inputs must all be of the same type.
Our prototype  attempts to detect  whether the logical property  is preserved
after the execution  of the predicate. If several inputs  or outputs are of the
same type,  all combinations are  considered.  Most implicit types  were not
considered % or "excluded" ?
when searching for property/predicate pairs, as they are less likely to yield
successful results.  For example, arguments of a primitive type like
\texttt{int}  are unlikely  to be  unaffected  by the  execution of  the
predicate.

% * explain what is considered a ``yes'':
% ** array indices are considered $\neq$ (i.e. implicit hypothesis $i \neq j, \forall i,j \in \text{Array Indices}$ as part of the decision procedure)
% ** both the true and the false exit labels are tested independently, success if either or both succeed. $\mathit{Prop}(\bar{\imath}) \rightarrow^{true} \Rightarrow \mathit{Pred}(\bar{\imath}, \bar{o}) \Rightarrow \mathit{Prop}(\bar{\i}) \rightarrow^{true}$, and the same thing for false.

This  prototype automatically  inspected  all  such property/predicate  pairs
found in the RSM/FSP layers. A property was considered to be preserved if its
dependency summary  for the argument  involved, when translated  to a set of
equalities,  formed a  subset of  the equalities  implied by  the predicate's
correlation  summary.  Both  the  \texttt{true} and  the \texttt{false}  exit
labels were  considered independently, and  the property is considered  to be
preserved (subject  to some conditions)  when it  is preserved for  either or
both exit labels. %% More precisely, given  a property
%% $\pi(\bar{\imath})[\mathit{true} \| \mathit{false}]$  and a predicate
%% $p(\bar{\imath}')[\ell: \bar{o}']$ where $i \in \bar{\imath}$,
%% $i' \in \bar{\imath}'$ and $o' \in \bar{o}'$ all have the same type, we
%% report success when it can deduce the following:
%
More precisely, given  a property
$\pi(\bar{\imath})[\mathit{true} | \mathit{false}]$  and a predicate
$p(\bar{\imath}')[\ell: \bar{o}']$, we report success when it can satisfy the
following:
%% \begin{align*}
%%                                         & \ell in \{\mathit{true}, \mathit{false}\}                                                                              \\
%%   \vphantom{a} \Rightarrow \vphantom{b} & i \neq j \quad \forall i,j \text{ where } \tau(i) = \mathit{Array{<}{\_}{>}} \wedge \tau(j) = \mathit{Array{<}{\_}{>}} \\
%%   \vphantom{a} \Rightarrow \vphantom{b} & \mathit{Prop}(\bar{\imath}) \xrightarrow{\ell}                                                                         \\
%%   \vphantom{a} \Rightarrow \vphantom{b} & \mathit{Pred}(\bar{\imath}, \bar{o}) \xrightarrow{\ell'}                                                               \\
%%   \vphantom{a} \Rightarrow \vphantom{b} & \mathit{Prop}(\bar{\i}) \xrightarrow{\ell}
%% \end{align*}

\begin{align}
% There is at least one of the exit labels {true,false}
  \label{eq:ch8:auto-mode-iio}
                                   & \exists\, i \in \bar{\imath}, i' \in \bar{\imath}', o' \in \bar{o}' \text{ such that } \Gamma(i) = \Gamma(i') = \Gamma(o')            \\
  \label{eq:ch8:auto-mode-ell}
  \vphantom{a} \wedge \vphantom{b} & \exists\, \ell \in \{\mathit{true}, \mathit{false}\}                                                                                  \\
% for which, assuming that the array indices involved are different
  \vphantom{a} \wedge \vphantom{b} & E(j) \neq E(k) \wedge E'(j) \neq E'(k) \quad \forall j,k \in \{\bar{\imath},\bar{\imath}',\bar{o}'\}                                  \\
                                   & \quad \text{when $j$ and $k$ are used as array indices}                                                                               \\
% the frame rule Prop(old-prop-arguments) => Pred(old-inputs)[\ell': new-outputs] => Prop(new-prop-arguments)
  \vphantom{a} \wedge \vphantom{b} & \left\langle E, \left[\;\mathit{Prop}(\bar{\imath}[i \rightarrow i'])[true|\mathit{false}]\;\right]\right\rangle \xrightarrow{\ell} E \\
  \vphantom{a} \wedge \vphantom{b} & \left\langle E, \left[\;\mathit{Pred}(\bar{\imath}')[\ell': \bar{o}|\ldots]\;\right]\right\rangle \xrightarrow{\ell'} E'              \\
  \label{eq:ch8:auto-mode-last}
\vphantom{a} \wedge \vphantom{b} & \left\langle E' \left[\;\mathit{Prop}(\bar{\imath}[i \rightarrow o'])[true|\mathit{false}]\;\right]\right\rangle \xrightarrow{\ell} E'
\end{align}
where $\bar{\imath}[i  \rightarrow i']$ and $\bar{\imath}[i  \rightarrow o']$
denote the sequence of variables $\bar{\imath}$  in which the variable $i$ is
replaced by the variable $i'$ (respectively $o'$).

% * :::::::::TODO::::::::: give some figures about the results

This initial  prototype was run on  the 398 explicit predicates and  235 properties of
the RSM/FSP layer of ProvenCore. Out of these, we filtered predicate/property
pairs for which the property has an input  $i$ of the same type as one of the
predicate's inputs $i'$ and one of  its outputs $o'$. These pairs involve 161
distinct predicates  and 165 distinct  properties. In total, there  were 8250
tuples    $(i,   i',    o',   \ell)$    which   satisfied    the   conditions
\ref{eq:ch8:auto-mode-iio} and \ref{eq:ch8:auto-mode-ell}.

This experiment allowed us, as a  first result, to automatically identify 102
predicates for which at least one  property is preserved under the conditions
\ref{eq:ch8:auto-mode-iio}~--~\ref{eq:ch8:auto-mode-last} stated  above.  For
many predicates,  it was possible to  show that, after the  execution of said
predicate,   several   properties   are    preserved   (up   to   33).    
Figure~\ref{fig:constplot-num-properties}  shows  an  overview  of  how  many
properties were inferred to be preserved  for each predicate. The blue region
at the bottom indicates how many  properties are inferred to be preserved for
a given predicate, while the red  region above shows how many properties were
compatible with the predicate, but were not inferred to be preserved.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      const plot, area style, % staircase (with \closedcycle at the end) or
      % ybar interval,        % histogram (without \closedcycle)
      ymax=50,
      ymin=0,
      minor y tick num = 1,
      xtick={0,20,...,100},
      major grid style={dotted},
      xmin=1,
      xmax=102,
      xlabel={Predicates},
      ylabel={Number of preserved properties inferred},
      width=\textwidth,
      ]
      %
      % sqlite3 all_auto.db "select (select count(*) from (select distinct prop from results where pred = pr)) as non from (select pred as pr, count(*) as c from (select distinct pred,prop from results where ans='yes') group by pr) order by c,non;" | nl | sed -e 's/\s\s*/ /g' -e 's/^ /(/' -e 's/ /, /' -e 's/$/)/'
      \pgfplotsset{cycle list shift=1}
      \addplot coordinates {
        (1, 5)
        (2, 7)
        (3, 13)
        (4, 16)
        (5, 38)
        (6, 41)
        (7, 41)
        (8, 41)
        (9, 41)
        (10, 41)
        (11, 41)
        (12, 42)
        (13, 47)
        (14, 47)
        (15, 47)
        (16, 47)
        (17, 47)
        (18, 50)
        (19, 50)
        (20, 50)
        (21, 50)
        (22, 50)
        (23, 50)
        (24, 50)
        (25, 13)
        (26, 13)
        (27, 13)
        (28, 13)
        (29, 38)
        (30, 40)
        (31, 35)
        (32, 35)
        (33, 35)
        (34, 38)
        (35, 38)
        (36, 38)
        (37, 38)
        (38, 13)
        (39, 38)
        (40, 38)
        (41, 38)
        (42, 38)
        (43, 38)
        (44, 7)
        (45, 35)
        (46, 35)
        (47, 38)
        (48, 38)
        (49, 38)
        (50, 38)
        (51, 38)
        (52, 38)
        (53, 38)
        (54, 38)
        (55, 38)
        (56, 38)
        (57, 7)
        (58, 35)
        (59, 35)
        (60, 35)
        (61, 35)
        (62, 35)
        (63, 35)
        (64, 35)
        (65, 38)
        (66, 38)
        (67, 38)
        (68, 39)
        (69, 13)
        (70, 13)
        (71, 13)
        (72, 35)
        (73, 35)
        (74, 13)
        (75, 13)
        (76, 13)
        (77, 13)
        (78, 16)
        (79, 16)
        (80, 16)
        (81, 16)
        (82, 31)
        (83, 31)
        (84, 31)
        (85, 31)
        (86, 31)
        (87, 31)
        (88, 31)
        (89, 31)
        (90, 31)
        (91, 31)
        (92, 31)
        (93, 31)
        (94, 31)
        (95, 35)
        (96, 38)
        (97, 35)
        (98, 35)
        (99, 35)
        (100, 35)
        (101, 35)
        (102, 35)
      }
      \closedcycle
      ;
      % 
      % sqlite3 all_auto.db "select c from (select pred as pr, count(*) as c, group_concat(prop) as props from (select distinct pred,prop from results where ans='yes') group by pr) order by c,(select count(*) from (select distinct prop from results where pred = pr));" | nl | sed -e 's/\s\s*/ /g' -e 's/^ /(/' -e 's/ /, /' -e 's/$/)/'
      \pgfplotsset{cycle list shift=-1}
      \addplot coordinates {
        (1, 1)
        (2, 1)
        (3, 1)
        (4, 1)
        (5, 1)
        (6, 1)
        (7, 1)
        (8, 1)
        (9, 1)
        (10, 1)
        (11, 1)
        (12, 1)
        (13, 1)
        (14, 1)
        (15, 1)
        (16, 1)
        (17, 1)
        (18, 1)
        (19, 1)
        (20, 1)
        (21, 1)
        (22, 1)
        (23, 1)
        (24, 1)
        (25, 2)
        (26, 2)
        (27, 2)
        (28, 2)
        (29, 2)
        (30, 2)
        (31, 3)
        (32, 3)
        (33, 3)
        (34, 3)
        (35, 3)
        (36, 3)
        (37, 3)
        (38, 4)
        (39, 4)
        (40, 4)
        (41, 4)
        (42, 4)
        (43, 4)
        (44, 5)
        (45, 5)
        (46, 5)
        (47, 5)
        (48, 5)
        (49, 5)
        (50, 5)
        (51, 5)
        (52, 5)
        (53, 5)
        (54, 5)
        (55, 5)
        (56, 5)
        (57, 6)
        (58, 6)
        (59, 6)
        (60, 6)
        (61, 6)
        (62, 6)
        (63, 6)
        (64, 6)
        (65, 6)
        (66, 6)
        (67, 6)
        (68, 6)
        (69, 7)
        (70, 7)
        (71, 7)
        (72, 7)
        (73, 7)
        (74, 9)
        (75, 9)
        (76, 9)
        (77, 9)
        (78, 12)
        (79, 12)
        (80, 13)
        (81, 14)
        (82, 22)
        (83, 22)
        (84, 23)
        (85, 23)
        (86, 26)
        (87, 26)
        (88, 27)
        (89, 27)
        (90, 27)
        (91, 27)
        (92, 29)
        (93, 29)
        (94, 29)
        (95, 30)
        (96, 31)
        (97, 32)
        (98, 33)
        (99, 33)
        (100, 33)
        (101, 33)
        (102, 33)
      }
      \closedcycle
      ;
    \end{axis}
  \end{tikzpicture}
  \caption[Distribution of the number of inferred preserved properties]{Distribution of the number of inferred preserved properties. Predicates are sorted along that criterion.}
  \label{fig:constplot-num-properties}
\end{figure}

Figure~\ref{fig:constplot-num-predicates} shows an overview  of how many
predicates were inferred  to be preserving each property. The  blue region at
the bottom  indicates how  many predicates  are inferred  to be  preserving a
given property,  while the red  region above  shows how many  predicates were
compatible with the property, but were not inferred to be preserving it.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      const plot, area style, % staircase (with \closedcycle at the end) or
      % ybar interval,        % histogram (without \closedcycle)
      ymax=61,
      ymin=0,
      minor y tick num = 1,
      xtick={0,20,...,80,90},
      major grid style={dotted},
      xmin=1,
      xmax=91,
      xlabel={Properties},
      ylabel={Number of predicates preserving the property inferred},
      width=\textwidth,
      ]
      % 
      % sqlite3 all_auto.db "select (select count(*) from (select distinct pred from results where prop = pr)) as non from (select prop as pr, count(*) as c from (select distinct prop,pred from results where ans='yes') group by pr) order by c,non;" | nl | sed -e 's/\s\s*/ /g' -e 's/^ /(/' -e 's/ /, /' -e 's/$/)/'
      \pgfplotsset{cycle list shift=1}
      \addplot coordinates {
        (1, 1)
        (2, 2)
        (3, 3)
        (4, 2)
        (5, 2)
        (6, 2)
        (7, 2)
        (8, 2)
        (9, 22)
        (10, 22)
        (11, 22)
        (12, 29)
        (13, 22)
        (14, 22)
        (15, 22)
        (16, 22)
        (17, 22)
        (18, 22)
        (19, 22)
        (20, 22)
        (21, 22)
        (22, 22)
        (23, 22)
        (24, 22)
        (25, 22)
        (26, 22)
        (27, 22)
        (28, 48)
        (29, 48)
        (30, 48)
        (31, 22)
        (32, 22)
        (33, 22)
        (34, 48)
        (35, 48)
        (36, 48)
        (37, 48)
        (38, 48)
        (39, 48)
        (40, 48)
        (41, 48)
        (42, 48)
        (43, 48)
        (44, 48)
        (45, 48)
        (46, 48)
        (47, 48)
        (48, 48)
        (49, 48)
        (50, 48)
        (51, 48)
        (52, 48)
        (53, 48)
        (54, 48)
        (55, 13)
        (56, 13)
        (57, 13)
        (58, 13)
        (59, 22)
        (60, 13)
        (61, 13)
        (62, 13)
        (63, 13)
        (64, 13)
        (65, 13)
        (66, 48)
        (67, 13)
        (68, 13)
        (69, 13)
        (70, 13)
        (71, 13)
        (72, 13)
        (73, 13)
        (74, 13)
        (75, 13)
        (76, 13)
        (77, 13)
        (78, 13)
        (79, 13)
        (80, 13)
        (81, 13)
        (82, 22)
        (83, 61)
        (84, 19)
        (85, 61)
        (86, 48)
        (87, 61)
        (88, 48)
        (89, 48)
        (90, 48)
        (91, 48)
      }
      \closedcycle
      ;
      % 
      % sqlite3 all_auto.db "select c from (select prop as pr, count(*) as c, group_concat(pred) as preds from (select distinct prop,pred from results where ans='yes') group by pr) order by c,(select count(*) from (select distinct pred from results where prop = pr));" | nl | sed -e 's/\s\s*/ /g' -e 's/^ /(/' -e 's/ /, /' -e 's/$/)/'
      \pgfplotsset{cycle list shift=-1}
      \addplot coordinates {
        (1, 1)
        (2, 1)
        (3, 1)
        (4, 2)
        (5, 2)
        (6, 2)
        (7, 2)
        (8, 2)
        (9, 2)
        (10, 2)
        (11, 3)
        (12, 3)
        (13, 4)
        (14, 4)
        (15, 4)
        (16, 4)
        (17, 4)
        (18, 4)
        (19, 4)
        (20, 4)
        (21, 4)
        (22, 4)
        (23, 4)
        (24, 4)
        (25, 5)
        (26, 7)
        (27, 7)
        (28, 7)
        (29, 7)
        (30, 7)
        (31, 8)
        (32, 8)
        (33, 8)
        (34, 8)
        (35, 8)
        (36, 8)
        (37, 8)
        (38, 8)
        (39, 8)
        (40, 8)
        (41, 8)
        (42, 8)
        (43, 8)
        (44, 8)
        (45, 8)
        (46, 8)
        (47, 8)
        (48, 8)
        (49, 8)
        (50, 8)
        (51, 8)
        (52, 8)
        (53, 8)
        (54, 8)
        (55, 11)
        (56, 11)
        (57, 11)
        (58, 11)
        (59, 11)
        (60, 12)
        (61, 12)
        (62, 12)
        (63, 12)
        (64, 12)
        (65, 12)
        (66, 12)
        (67, 13)
        (68, 13)
        (69, 13)
        (70, 13)
        (71, 13)
        (72, 13)
        (73, 13)
        (74, 13)
        (75, 13)
        (76, 13)
        (77, 13)
        (78, 13)
        (79, 13)
        (80, 13)
        (81, 13)
        (82, 13)
        (83, 16)
        (84, 19)
        (85, 19)
        (86, 33)
        (87, 34)
        (88, 36)
        (89, 37)
        (90, 45)
        (91, 46)
      }
      \closedcycle
      ;
    \end{axis}
  \end{tikzpicture}
  \caption[Distribution of the number of inferred predicates for which a property is preserved]{Distribution of the number of inferred predicates for which a property is preserved. Properties are sorted along that criterion.}
  \label{fig:constplot-num-predicates}
\end{figure}

It is  worth noting  that in both figures~\ref{fig:constplot-num-properties}
and~\ref{fig:constplot-num-predicates},  the   red   zone contains
properties (respectively predicates) which could fall into these cases:
\begin{itemize}
\item  The  property is  actually  threatened  by  the predicate  (respectively  the
  predicate threatens the property);
\item  The  property   is  not  threatened  (respectively the predicate  is  not
  threatening), but proving so requires  more information that is obtained by
  our  dependency and  correlation  analysis.  For  example,  a more  precise
  dependency or correlation analysis  (e.g. tracking constructor evolution as
  presented in  \ref{sec:cor:cons}) could  be needed.   A numerical  or value
  analysis  could also  help  determine  that the  parts  of  the input  data
  structure which  are modified  by the  predicate and  on which  the logical
  property also depends still satisfy the property after the execution of the
  predicate.   Alternatively, the  preservation  of these  properties can  be
  demonstrated using an interactive prover.
\item  The  property   is  not  threatened  (respectively the predicate  is  not
  threatening), and  the dependency and correlation  summaries contain enough
  information to  prove the non-interference  of the predicate  and property,
  but our decision procedure prototype failed to infer it. This can be due to
  a timeout  (this initial prototype has  not been optimized at  all, and can
  take  a substantial  time in  some cases),  or to  precision losses  in the
  decision procedure prototype itself.
\end{itemize}


\section{Related work}

\section{Conclusions}

\bibliographystyle{alpha}
\bibliography{biblio}

\end{document}
